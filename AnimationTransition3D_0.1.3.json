{
  "author": "",
  "category": "General",
  "extensionNamespace": "",
  "fullName": "Animation transition 3d",
  "helpPath": "https://github.com/GuestGD/Animation_transition3D_Gdevelop",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXZpZGVvLW1pbnVzLW91dGxpbmUiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTUgOFYxNkg1VjhIMTVNMTYgNkg0QzMuNDUgNiAzIDYuNDUgMyA3VjE3QzMgMTcuNTUgMy40NSAxOCA0IDE4SDE2QzE2LjU1IDE4IDE3IDE3LjU1IDE3IDE3VjEzLjVMMjEgMTcuNVY2LjVMMTcgMTAuNVY3QzE3IDYuNDUgMTYuNTUgNiAxNiA2TTEzIDEzSDdWMTFIMTNWMTNaIiAvPjwvc3ZnPg==",
  "name": "AnimationTransition3D",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/dc34dfac0916a53f58ba6fc06801a4ea79e144b2cc1c200fc07ada8a971ce6b7_video-minus-outline.svg",
  "shortDescription": "Animation transition 3d",
  "version": "0.1",
  "description": "Make a smooth transition between any mesh animations",
  "tags": [
    "animation 3d transition"
  ],
  "authorIds": [
    "W0yoMQqOeiULIwY1i1Qd8tprOyD2"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "description": "Play animation by name",
      "fullName": "Play animation by name",
      "functionType": "Action",
      "name": "Play",
      "private": true,
      "sentence": "Play animation by name for: _PARAM1_ Animation name: _PARAM2_ Speed: _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length >0) {",
            "    const objectName = objects[0].getName();",
            "    const animationName = eventsFunctionContext.getArgument(\"animationName\"); ",
            "    const speedScale = eventsFunctionContext.getArgument(\"playSpeed\"); ",
            "",
            "    const object = runtimeScene.getObjects(objectName)[0];",
            "",
            "    if (object && object instanceof gdjs.Model3DRuntimeObject) {",
            "        const currentSpeed = object.getAnimationSpeedScale();",
            "",
            "        const renderer = object.getRenderer();",
            "        const isEnded = renderer.hasAnimationEnded();",
            "        if (renderer.hasAnimationEnded()) {",
            "            if (currentSpeed !== speedScale) {",
            "                object.setAnimationSpeedScale(speedScale);",
            "            }",
            "            object.setAnimationElapsedTime(0)",
            "            renderer.playAnimation(animationName);",
            "        }",
            "    }",
            "",
            "};",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        },
        {
          "description": "Speed of animation",
          "name": "playSpeed",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Get bones info by animation names",
      "fullName": "Get bones info by animation names",
      "functionType": "Action",
      "name": "GetBonesInfoByNames",
      "sentence": "Get bones info by animation names for: _PARAM1_ Animation names array: _PARAM2_ Get all animations: _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "inverted": true,
                "value": "GetArgumentAsBoolean"
              },
              "parameters": [
                "\"allAnimation\""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (objects.length > 0) {",
                "    objects[0].get3DRendererObject().traverse((node) => {",
                "        if (node.isMesh || node.type === 'ParticleEmitter' || node.isLight) {",
                "            node.name = objects[0].getName();",
                "        }",
                "    });",
                "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "    const threeMesh = scene.getObjectByName(objects[0].getName());",
                "    const animationNames = eventsFunctionContext.getArgument(\"animationNames\").split(',').map(name => name.trim());",
                "    const speedScale = 2000;",
                "    const renderer = objects[0].getRenderer();",
                "    const object = runtimeScene.getObjects(objects[0].getName())[0];",
                "",
                "    const playAnimationAndCaptureBones = (animationName, callback) => {",
                "        threeMesh.userData[animationName + \"_start\"] = {};",
                "        threeMesh.userData[animationName + \"_end\"] = {};",
                "",
                "        if (object && object instanceof gdjs.Model3DRuntimeObject) {",
                "            object.setAnimationName(animationName); ",
                "            object.setAnimationElapsedTime(0); ",
                "",
                "            threeMesh.traverse((node) => {",
                "                if (node.isSkinnedMesh) {",
                "                    node.skeleton.bones.forEach((bone) => {",
                "                        threeMesh.userData[animationName + \"_start\"][bone.name] = {",
                "                            position: bone.position.clone(),",
                "                            rotation: bone.rotation.clone(),",
                "                            scale: bone.scale.clone(),",
                "                        };",
                "                    });",
                "                }",
                "            });",
                "",
                "            object.setAnimationSpeedScale(speedScale);",
                "            renderer.playAnimation(animationName); ",
                "",
                "            const checkAnimationEnd = () => {",
                "                if (renderer.hasAnimationEnded()) {",
                "                    threeMesh.traverse((node) => {",
                "                        if (node.isSkinnedMesh) {",
                "                            node.skeleton.bones.forEach((bone) => {",
                "                                threeMesh.userData[animationName + \"_end\"][bone.name] = {",
                "                                    position: bone.position.clone(),",
                "                                    rotation: bone.rotation.clone(),",
                "                                    scale: bone.scale.clone(),",
                "                                };",
                "                            });",
                "                        }",
                "                    });",
                "",
                "                    object.setAnimationSpeedScale(1);",
                "                    if (callback) callback();",
                "                } else {",
                "                    setTimeout(checkAnimationEnd, 100);",
                "                }",
                "            };",
                "",
                "            checkAnimationEnd();",
                "        }",
                "    };",
                "",
                "    const playAnimationsSequentially = (names, index = 0) => {",
                "        if (index < names.length) {",
                "            playAnimationAndCaptureBones(names[index], () => playAnimationsSequentially(names, index + 1));",
                "        }",
                "    };",
                "",
                "    playAnimationsSequentially(animationNames);",
                "}"
              ],
              "parameterObjects": "id",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "GetArgumentAsBoolean"
              },
              "parameters": [
                "\"allAnimation\""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (objects.length > 0) {",
                "    objects[0].get3DRendererObject().traverse((node) => {",
                "        if (node.isMesh || node.type === 'ParticleEmitter' || node.isLight) {",
                "            node.name = objects[0].getName();",
                "        }",
                "    });",
                "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "    const threeMesh = scene.getObjectByName(objects[0].getName());",
                "    const speedScale = 2000;",
                "    const renderer = objects[0].getRenderer();",
                "    const object = runtimeScene.getObjects(objects[0].getName())[0];",
                "",
                "    const animationNames = object._animations.map(animation => animation.source);",
                "",
                "    const playAnimationAndCaptureBones = (animationName, callback) => {",
                "        threeMesh.userData[animationName + \"_start\"] = {};",
                "        threeMesh.userData[animationName + \"_end\"] = {};",
                "",
                "        if (object && object instanceof gdjs.Model3DRuntimeObject) {",
                "            object.setAnimationName(animationName); ",
                "            object.setAnimationElapsedTime(0); ",
                "",
                "            threeMesh.traverse((node) => {",
                "                if (node.isSkinnedMesh) {",
                "                    node.skeleton.bones.forEach((bone) => {",
                "                        threeMesh.userData[animationName + \"_start\"][bone.name] = {",
                "                            position: bone.position.clone(),",
                "                            rotation: bone.rotation.clone(),",
                "                            scale: bone.scale.clone(),",
                "                        };",
                "                    });",
                "                }",
                "            });",
                "",
                "            object.setAnimationSpeedScale(speedScale); ",
                "            renderer.playAnimation(animationName);",
                "",
                "            const checkAnimationEnd = () => {",
                "                if (renderer.hasAnimationEnded()) {",
                "                    threeMesh.traverse((node) => {",
                "                        if (node.isSkinnedMesh) {",
                "                            node.skeleton.bones.forEach((bone) => {",
                "                                threeMesh.userData[animationName + \"_end\"][bone.name] = {",
                "                                    position: bone.position.clone(),",
                "                                    rotation: bone.rotation.clone(),",
                "                                    scale: bone.scale.clone(),",
                "                                };",
                "                            });",
                "                        }",
                "                    });",
                "",
                "                    object.setAnimationSpeedScale(1); ",
                "                    if (callback) callback();",
                "                } else {",
                "                    setTimeout(checkAnimationEnd, 100);",
                "                }",
                "            };",
                "",
                "            checkAnimationEnd();",
                "        }",
                "    };",
                "",
                "    const playAnimationsSequentially = (names, index = 0) => {",
                "        if (index < names.length) {",
                "            playAnimationAndCaptureBones(names[index], () => playAnimationsSequentially(names, index + 1));",
                "        }",
                "    };",
                "",
                "    playAnimationsSequentially(animationNames);",
                "}"
              ],
              "parameterObjects": "id",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Name of object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation names array",
          "longDescription": "Animation names (example: \"name1,name2,name3...\")",
          "name": "animationNames",
          "type": "string"
        },
        {
          "description": "Use for all existing animations of the object",
          "longDescription": "Use for all existing animations of the object",
          "name": "allAnimation",
          "type": "yesorno"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Animation transition",
      "fullName": "Animation transition",
      "functionType": "Action",
      "name": "MoveBones",
      "sentence": "Animation transition of: _PARAM1_ To: _PARAM2_ Target frame: _PARAM3_ Speed: _PARAM4_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "let isLoopActive = true;",
            "",
            "const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "const speed = eventsFunctionContext.getArgument(\"playSpeed\");",
            "",
            "function lerp(start, end, alpha) {",
            "  return start + (end - start) * Math.min(1, alpha);",
            "}",
            "",
            "function positionsAreEqual(pos1, pos2) {",
            "  const distance = Math.sqrt(",
            "    Math.pow(pos1.x - pos2.x, 2) +",
            "    Math.pow(pos1.y - pos2.y, 2) +",
            "    Math.pow(pos1.z - pos2.z, 2)",
            "  );",
            "  return distance < 0.001;",
            "}",
            "",
            "function rotationsAreEqual(rot1, rot2) {",
            "  const distance = Math.sqrt(",
            "    Math.pow(rot1.x - rot2.x, 2) +",
            "    Math.pow(rot1.y - rot2.y, 2) +",
            "    Math.pow(rot1.z - rot2.z, 2)",
            "  );",
            "  return distance < 0.001;",
            "}",
            "",
            "function scalesAreEqual(scale1, scale2) {",
            "  const distance = Math.sqrt(",
            "    Math.pow(scale1.x - scale2.x, 2) +",
            "    Math.pow(scale1.y - scale2.y, 2) +",
            "    Math.pow(scale1.z - scale2.z, 2)",
            "  );",
            "  return distance < 0.001;",
            "}",
            "",
            "function quaternionsAreEqual(quat1, quat2) {",
            "  return quat1.angleTo(quat2) < 0.001;",
            "}",
            "",
            "function updateBonePositionsFromUserData(object, deltaTime, animationName, frame, callback) {",
            "  let targetDataKey;",
            "  switch (frame) {",
            "    case \"startFrame\":",
            "      targetDataKey = `${animationName}_start`;",
            "      break;",
            "    case \"endFrame\":",
            "      targetDataKey = `${animationName}_end`;",
            "      break;",
            "    default:",
            "      //console.log(`Unexpected frame: ${frame}`);",
            "      return;",
            "  }",
            "",
            "  const targetDataCollection = object.userData[targetDataKey];",
            "",
            "  if (!targetDataCollection) {",
            "    return;",
            "  }",
            "",
            "  let allPositionsReached = true;",
            "",
            "  object.traverse((child) => {",
            "    if (child.isSkinnedMesh && child.skeleton) {",
            "      child.skeleton.bones.forEach((bone) => {",
            "        const targetData = targetDataCollection[bone.name];",
            "        if (targetData) {",
            "          const targetQuaternion = new THREE.Quaternion().setFromEuler(targetData.rotation);",
            "          const currentQuaternion = bone.quaternion.clone();",
            "          const shortestQuaternion = new THREE.Quaternion().copy(currentQuaternion).slerp(targetQuaternion, speed * deltaTime);",
            "",
            "          const positionReached = positionsAreEqual(bone.position, targetData.position);",
            "          const rotationReached = quaternionsAreEqual(bone.quaternion, targetQuaternion);",
            "          const scaleReached = scalesAreEqual(bone.scale, targetData.scale);",
            "",
            "          if (!positionReached || !rotationReached || !scaleReached) {",
            "            allPositionsReached = false;",
            "",
            "            bone.position.x = lerp(bone.position.x, targetData.position.x, speed * deltaTime);",
            "            bone.position.y = lerp(bone.position.y, targetData.position.y, speed * deltaTime);",
            "            bone.position.z = lerp(bone.position.z, targetData.position.z, speed * deltaTime);",
            "",
            "            bone.quaternion.copy(shortestQuaternion);",
            "",
            "            bone.scale.x = lerp(bone.scale.x, targetData.scale.x, speed * deltaTime);",
            "            bone.scale.y = lerp(bone.scale.y, targetData.scale.y, speed * deltaTime);",
            "            bone.scale.z = lerp(bone.scale.z, targetData.scale.z, speed * deltaTime);",
            "          }",
            "        }",
            "      });",
            "    }",
            "  });",
            "",
            "  if (!allPositionsReached) {",
            "    object.userData.currentState = `${targetDataKey}_active`;",
            "    object.userData[targetDataKey].reached = false;",
            "",
            "    setTimeout(() => {",
            "      updateBonePositionsFromUserData(object, deltaTime, animationName, frame, callback);",
            "    }, 16);",
            "  } else {",
            "    object.userData[targetDataKey].reached = true;",
            "    object.userData[`${targetDataKey}_reached`] = {",
            "      position: object.position.clone(),",
            "      rotation: object.rotation.clone(),",
            "      scale: object.scale.clone()",
            "    };",
            "    ",
            "    objects[0].pauseAnimation();",
            "    objects[0].setAnimationName(animationName);",
            "    objects[0].setAnimationElapsedTime(0);",
            "    objects[0].resumeAnimation();",
            "    object.userData.currentState = `${targetDataKey}_not_active`;",
            "",
            "    if (callback) callback();",
            "  }",
            "}",
            "",
            "if (objects.length > 0) {",
            "  const objectName = objects[0].getName();",
            "  const threeModel = threeScene.getObjectByName(objectName);",
            "  const deltaTime = runtimeScene.getTimeManager().getElapsedTime() / 1000.0;",
            "  const animationName = eventsFunctionContext.getArgument(\"animationName\");",
            "  const frame = eventsFunctionContext.getArgument(\"pickFrame\");",
            "",
            "  if (threeModel) {",
            "    updateBonePositionsFromUserData(threeModel, deltaTime, animationName, frame, () => {",
            "      isLoopActive = false; ",
            "    });",
            "  }",
            "}",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        },
        {
          "description": "Target frame",
          "longDescription": "Pick start or end frame of the animation",
          "name": "pickFrame",
          "supplementaryInformation": "[\"startFrame\",\"endFrame\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Bones moving speed",
          "name": "playSpeed",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Is transition in progress",
      "fullName": "Is transition in progress",
      "functionType": "ExpressionAndCondition",
      "name": "IsMovingInProgress",
      "sentence": "Is transition in progress for: _PARAM1_ Animation name: _PARAM2_ Target frame: _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function checkAnimationState(runtimeScene, object, animationName, frame) {",
            "    var currentState = object.userData.currentState;",
            "    var expectedState = `${animationName}_${frame}_active`;",
            "    ",
            "    if (currentState === expectedState) {",
            "        return true;",
            "    } else {",
            "        return false;",
            "    }",
            "}",
            "",
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const threeModel = threeScene.getObjectByName(objects[0].getName());",
            "    let animationState = false; ",
            "",
            "    if (threeModel) {",
            "        animationState = checkAnimationState(",
            "            runtimeScene,",
            "            threeModel,",
            "            eventsFunctionContext.getArgument(\"animationName\"),",
            "            eventsFunctionContext.getArgument(\"frame\")",
            "        );",
            "    }",
            "",
            "    eventsFunctionContext.returnValue = animationState;",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "stringWithSelector"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        },
        {
          "description": "Target frame",
          "name": "frame",
          "supplementaryInformation": "[\"start\",\"end\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}