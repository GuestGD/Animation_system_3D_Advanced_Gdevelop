{
  "author": "",
  "category": "General",
  "extensionNamespace": "",
  "fullName": "Animation transition 3d",
  "helpPath": "https://github.com/GuestGD/Animation_transition3D_Gdevelop",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXZpZGVvLW1pbnVzLW91dGxpbmUiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTUgOFYxNkg1VjhIMTVNMTYgNkg0QzMuNDUgNiAzIDYuNDUgMyA3VjE3QzMgMTcuNTUgMy40NSAxOCA0IDE4SDE2QzE2LjU1IDE4IDE3IDE3LjU1IDE3IDE3VjEzLjVMMjEgMTcuNVY2LjVMMTcgMTAuNVY3QzE3IDYuNDUgMTYuNTUgNiAxNiA2TTEzIDEzSDdWMTFIMTNWMTNaIiAvPjwvc3ZnPg==",
  "name": "AnimationTransition3D",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/dc34dfac0916a53f58ba6fc06801a4ea79e144b2cc1c200fc07ada8a971ce6b7_video-minus-outline.svg",
  "shortDescription": "Animation transition 3d",
  "version": "0.1",
  "description": "Make a smooth transition between any mesh animations",
  "tags": [
    "animation 3d transition"
  ],
  "authorIds": [
    "W0yoMQqOeiULIwY1i1Qd8tprOyD2"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "description": "Play animation by name",
      "fullName": "Play animation by name",
      "functionType": "Action",
      "name": "Play",
      "private": true,
      "sentence": "Play animation by name for: _PARAM1_ Animation name: _PARAM2_ Speed: _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length >0) {",
            "    const objectName = objects[0].getName();",
            "    const animationName = eventsFunctionContext.getArgument(\"animationName\"); ",
            "    const speedScale = eventsFunctionContext.getArgument(\"playSpeed\"); ",
            "",
            "    const object = runtimeScene.getObjects(objectName)[0];",
            "",
            "    if (object && object instanceof gdjs.Model3DRuntimeObject) {",
            "        const currentSpeed = object.getAnimationSpeedScale();",
            "",
            "        const renderer = object.getRenderer();",
            "        const isEnded = renderer.hasAnimationEnded();",
            "        if (renderer.hasAnimationEnded()) {",
            "            if (currentSpeed !== speedScale) {",
            "                object.setAnimationSpeedScale(speedScale);",
            "            }",
            "            object.setAnimationElapsedTime(0)",
            "            renderer.playAnimation(animationName);",
            "        }",
            "    }",
            "",
            "};",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        },
        {
          "description": "Speed of animation",
          "name": "playSpeed",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Get bones info by animation names",
      "fullName": "Get bones info by animation names",
      "functionType": "Action",
      "name": "GetBonesInfoByNames",
      "sentence": "Get bones info by animation names for: _PARAM1_ Animation names array: _PARAM2_ Get all animations: _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "inverted": true,
                "value": "GetArgumentAsBoolean"
              },
              "parameters": [
                "\"allAnimation\""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (objects.length > 0) {",
                "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "    objects.forEach((obj, index) => {",
                "        const skinnedMeshList = [];",
                "        const gdName = obj.getName() + obj.getUniqueId();",
                "        const rendererObject = obj.get3DRendererObject();",
                "        if (rendererObject) {",
                "            rendererObject.traverse((node) => {",
                "                if (node.isSkinnedMesh && node.material.isMaterial) {",
                "                    skinnedMeshList.push(node.uuid); ",
                "     ",
                "",
                "                    const threeMesh = node;",
                "                    const animationNames = eventsFunctionContext.getArgument(\"animationNames\").split(',').map(name => name.trim());",
                "                    const speedScale = 2000;",
                "                    const renderer = obj.getRenderer();",
                "                    const object = obj;",
                "",
                "                    const playAnimationAndCaptureBones = (animationName, callback) => {",
                "                        node.userData[animationName + \"_start\"] = {};",
                "                        node.userData[animationName + \"_end\"] = {};",
                "",
                "                        if (object && object instanceof gdjs.Model3DRuntimeObject) {",
                "                            obj.setAnimationName(animationName); ",
                "                            obj.setAnimationElapsedTime(0); ",
                "",
                "                            node.traverse((node) => {",
                "                                if (node.isSkinnedMesh) {",
                "                                    node.skeleton.bones.forEach((bone) => {",
                "                                        node.userData[animationName + \"_start\"][bone.name] = {",
                "                                            position: bone.position.clone(),",
                "                                            rotation: bone.rotation.clone(),",
                "                                            scale: bone.scale.clone(),",
                "                                        };",
                "                                    });",
                "                                }",
                "                            });",
                "",
                "                            obj.setAnimationSpeedScale(speedScale);",
                "                            renderer.playAnimation(animationName); ",
                "",
                "                            const checkAnimationEnd = () => {",
                "                                if (renderer.hasAnimationEnded()) {",
                "                                    node.traverse((node) => {",
                "                                        if (node.isSkinnedMesh) {",
                "                                            node.skeleton.bones.forEach((bone) => {",
                "                                                node.userData[animationName + \"_end\"][bone.name] = {",
                "                                                    position: bone.position.clone(),",
                "                                                    rotation: bone.rotation.clone(),",
                "                                                    scale: bone.scale.clone(),",
                "                                                };",
                "                                            });",
                "                                        }",
                "                                    });",
                "",
                "                                    obj.setAnimationSpeedScale(1);",
                "                                    if (callback) callback();",
                "                                } else {",
                "                                    setTimeout(checkAnimationEnd, 100);",
                "                                }",
                "                            };",
                "",
                "                            checkAnimationEnd();",
                "                        }",
                "                    };",
                "",
                "                    const playAnimationsSequentially = (names, index = 0, finalCallback) => {",
                "                        if (index < names.length) {",
                "                            playAnimationAndCaptureBones(names[index], () => playAnimationsSequentially(names, index + 1, finalCallback));",
                "                        } else {",
                "                            if (finalCallback) finalCallback();",
                "                        }",
                "                    };",
                "",
                "                    playAnimationsSequentially(animationNames, 0, () => {",
                "                        obj.setAnimationElapsedTime(1);",
                "                        console.log(`All animations for object ${gdName} have been played and their bones info recorded.`);",
                "                    });",
                "                }",
                "            });             ",
                "        }",
                "",
                "        if (!scene.userData[gdName]) {",
                "            scene.userData[gdName] = {",
                "                skinnedMesh: {}",
                "            };",
                "        }",
                "",
                "        skinnedMeshList.forEach((name, index) => {",
                "            scene.userData[gdName].skinnedMesh[index] = name;",
                "        }); ",
                "    });",
                "}"
              ],
              "parameterObjects": "id",
              "useStrict": true,
              "eventsSheetExpanded": true
            },
            {
              "disabled": true,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (objects.length > 0) {",
                "    objects[0].get3DRendererObject().traverse((node) => {",
                "        if (node.isMesh || node.type === 'ParticleEmitter' || node.isLight) {",
                "            node.name = objects[0].getName();",
                "        }",
                "    });",
                "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "    const threeMesh = scene.getObjectByName(objects[0].getName());",
                "    const animationNames = eventsFunctionContext.getArgument(\"animationNames\").split(',').map(name => name.trim());",
                "    const speedScale = 2000;",
                "    const renderer = objects[0].getRenderer();",
                "    const object = runtimeScene.getObjects(objects[0].getName())[0];",
                "",
                "    const playAnimationAndCaptureBones = (animationName, callback) => {",
                "        threeMesh.userData[animationName + \"_start\"] = {};",
                "        threeMesh.userData[animationName + \"_end\"] = {};",
                "",
                "        if (object && object instanceof gdjs.Model3DRuntimeObject) {",
                "            object.setAnimationName(animationName); ",
                "            object.setAnimationElapsedTime(0); ",
                "",
                "            threeMesh.traverse((node) => {",
                "                if (node.isSkinnedMesh) {",
                "                    node.skeleton.bones.forEach((bone) => {",
                "                        threeMesh.userData[animationName + \"_start\"][bone.name] = {",
                "                            position: bone.position.clone(),",
                "                            rotation: bone.rotation.clone(),",
                "                            scale: bone.scale.clone(),",
                "                        };",
                "                    });",
                "                }",
                "            });",
                "",
                "            object.setAnimationSpeedScale(speedScale);",
                "            renderer.playAnimation(animationName); ",
                "",
                "            const checkAnimationEnd = () => {",
                "                if (renderer.hasAnimationEnded()) {",
                "                    threeMesh.traverse((node) => {",
                "                        if (node.isSkinnedMesh) {",
                "                            node.skeleton.bones.forEach((bone) => {",
                "                                threeMesh.userData[animationName + \"_end\"][bone.name] = {",
                "                                    position: bone.position.clone(),",
                "                                    rotation: bone.rotation.clone(),",
                "                                    scale: bone.scale.clone(),",
                "                                };",
                "                            });",
                "                        }",
                "                    });",
                "",
                "                    object.setAnimationSpeedScale(1);",
                "                    if (callback) callback();",
                "                } else {",
                "                    setTimeout(checkAnimationEnd, 100);",
                "                }",
                "            };",
                "",
                "            checkAnimationEnd();",
                "        }",
                "    };",
                "",
                "    const playAnimationsSequentially = (names, index = 0) => {",
                "        if (index < names.length) {",
                "            playAnimationAndCaptureBones(names[index], () => playAnimationsSequentially(names, index + 1));",
                "        }",
                "    };",
                "",
                "    playAnimationsSequentially(animationNames);",
                "}"
              ],
              "parameterObjects": "id",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        },
        {
          "folded": true,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "GetArgumentAsBoolean"
              },
              "parameters": [
                "\"allAnimation\""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (objects.length > 0) {",
                "    objects[0].get3DRendererObject().traverse((node) => {",
                "        if (node.isMesh || node.type === 'ParticleEmitter' || node.isLight) {",
                "            node.name = objects[0].getName();",
                "        }",
                "    });",
                "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "    const threeMesh = scene.getObjectByName(objects[0].getName());",
                "    const speedScale = 2000;",
                "    const renderer = objects[0].getRenderer();",
                "    const object = runtimeScene.getObjects(objects[0].getName())[0];",
                "",
                "    const animationNames = object._animations.map(animation => animation.source);",
                "",
                "    const playAnimationAndCaptureBones = (animationName, callback) => {",
                "        threeMesh.userData[animationName + \"_start\"] = {};",
                "        threeMesh.userData[animationName + \"_end\"] = {};",
                "",
                "        if (object && object instanceof gdjs.Model3DRuntimeObject) {",
                "            object.setAnimationName(animationName); ",
                "            object.setAnimationElapsedTime(0); ",
                "",
                "            threeMesh.traverse((node) => {",
                "                if (node.isSkinnedMesh) {",
                "                    node.skeleton.bones.forEach((bone) => {",
                "                        threeMesh.userData[animationName + \"_start\"][bone.name] = {",
                "                            position: bone.position.clone(),",
                "                            rotation: bone.rotation.clone(),",
                "                            scale: bone.scale.clone(),",
                "                        };",
                "                    });",
                "                }",
                "            });",
                "",
                "            object.setAnimationSpeedScale(speedScale); ",
                "            renderer.playAnimation(animationName);",
                "",
                "            const checkAnimationEnd = () => {",
                "                if (renderer.hasAnimationEnded()) {",
                "                    threeMesh.traverse((node) => {",
                "                        if (node.isSkinnedMesh) {",
                "                            node.skeleton.bones.forEach((bone) => {",
                "                                threeMesh.userData[animationName + \"_end\"][bone.name] = {",
                "                                    position: bone.position.clone(),",
                "                                    rotation: bone.rotation.clone(),",
                "                                    scale: bone.scale.clone(),",
                "                                };",
                "                            });",
                "                        }",
                "                    });",
                "",
                "                    object.setAnimationSpeedScale(1); ",
                "                    if (callback) callback();",
                "                } else {",
                "                    setTimeout(checkAnimationEnd, 100);",
                "                }",
                "            };",
                "",
                "            checkAnimationEnd();",
                "        }",
                "    };",
                "",
                "    const playAnimationsSequentially = (names, index = 0) => {",
                "        if (index < names.length) {",
                "            playAnimationAndCaptureBones(names[index], () => playAnimationsSequentially(names, index + 1));",
                "        }",
                "    };",
                "",
                "    playAnimationsSequentially(animationNames);",
                "}"
              ],
              "parameterObjects": "id",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ]
        }
      ],
      "parameters": [
        {
          "description": "Name of object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation names array",
          "longDescription": "Animation names (example: \"name1,name2,name3...\")",
          "name": "animationNames",
          "type": "string"
        },
        {
          "description": "Use to get all existing animations of the object  ",
          "longDescription": "Use to get all existing animations of the object  ",
          "name": "allAnimation",
          "type": "yesorno"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Animation transition",
      "fullName": "Animation transition",
      "functionType": "Action",
      "name": "MoveBones",
      "sentence": "Animation transition of: _PARAM1_ To: _PARAM2_ Target frame: _PARAM3_ Speed start: _PARAM4_  Speed end: _PARAM5_  indexArgument: _PARAM6_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const indexArgument = eventsFunctionContext.getArgument(\"indexArgument\") || 0;",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "        const speedStart = eventsFunctionContext.getArgument(\"speedStart\") || 1;",
            "        const speedEnd = eventsFunctionContext.getArgument(\"speedEnd\") || 1;",
            "        let speed = speedStart; ",
            "        const animationName = eventsFunctionContext.getArgument(\"animationName\");",
            "        const frame = eventsFunctionContext.getArgument(\"pickFrame\") || \"startFrame\";",
            "",
            "        if (!scene.userData || !scene.userData[gdName] || !scene.userData[gdName].skinnedMesh) {",
            "            return;",
            "        }",
            "",
            "        const pickedName = scene.userData[gdName].skinnedMesh[indexArgument];",
            "",
            "        if (rendererObject && pickedName) {",
            "            let isLoopActive = true;",
            "",
            "            function lerp(start, end, alpha) {",
            "                return start + (end - start) * Math.min(1, alpha);",
            "            }",
            "",
            "            function positionsAreEqual(pos1, pos2) {",
            "                const distance = Math.sqrt(",
            "                    Math.pow(pos1.x - pos2.x, 2) +",
            "                    Math.pow(pos1.y - pos2.y, 2) +",
            "                    Math.pow(pos1.z - pos2.z, 2)",
            "                );",
            "                return distance < 0.001;",
            "            }",
            "",
            "            function rotationsAreEqual(rot1, rot2) {",
            "                const distance = Math.sqrt(",
            "                    Math.pow(rot1.x - rot2.x, 2) +",
            "                    Math.pow(rot1.y - rot2.y, 2) +",
            "                    Math.pow(rot1.z - rot2.z, 2)",
            "                );",
            "                return distance < 0.001;",
            "            }",
            "",
            "            function scalesAreEqual(scale1, scale2) {",
            "                const distance = Math.sqrt(",
            "                    Math.pow(scale1.x - scale2.x, 2) +",
            "                    Math.pow(scale1.y - scale2.y, 2) +",
            "                    Math.pow(scale1.z - scale2.z, 2)",
            "                );",
            "                return distance < 0.001;",
            "            }",
            "",
            "            function quaternionsAreEqual(quat1, quat2) {",
            "                return quat1.angleTo(quat2) < 0.001;",
            "            }",
            "",
            "            function updateBonePositionsFromUserData(object, deltaTime, animationName, frame, callback) {",
            "                const node = object;",
            "                let targetDataKey;",
            "",
            "                switch (frame) {",
            "                    case \"startFrame\":",
            "                        targetDataKey = `${animationName}_start`;",
            "                        break;",
            "                    case \"endFrame\":",
            "                        targetDataKey = `${animationName}_end`;",
            "                        break;",
            "                    default:",
            "                        return;",
            "                }",
            "",
            "                const targetDataCollection = node.userData[targetDataKey];",
            "",
            "                if (!targetDataCollection) {",
            "                    return;",
            "                }",
            "",
            "                let allPositionsReached = true;",
            "",
            "                node.traverse((child) => {",
            "                    if (child.isSkinnedMesh && child.skeleton) {",
            "                        child.skeleton.bones.forEach((bone) => {",
            "                            const targetData = targetDataCollection[bone.name];",
            "                            if (targetData) {",
            "                                const targetQuaternion = new THREE.Quaternion().setFromEuler(targetData.rotation);",
            "                                const currentQuaternion = bone.quaternion.clone();",
            "                                const shortestQuaternion = new THREE.Quaternion().copy(currentQuaternion).slerp(targetQuaternion, speed * deltaTime);",
            "",
            "                                const positionReached = positionsAreEqual(bone.position, targetData.position);",
            "                                const rotationReached = quaternionsAreEqual(bone.quaternion, targetQuaternion);",
            "                                const scaleReached = scalesAreEqual(bone.scale, targetData.scale);",
            "",
            "                                if (!positionReached || !rotationReached || !scaleReached) {",
            "                                    allPositionsReached = false;",
            "",
            "                                    bone.position.x = lerp(bone.position.x, targetData.position.x, speed * deltaTime);",
            "                                    bone.position.y = lerp(bone.position.y, targetData.position.y, speed * deltaTime);",
            "                                    bone.position.z = lerp(bone.position.z, targetData.position.z, speed * deltaTime);",
            "",
            "                                    bone.quaternion.copy(shortestQuaternion);",
            "",
            "                                    bone.scale.x = lerp(bone.scale.x, targetData.scale.x, speed * deltaTime);",
            "                                    bone.scale.y = lerp(bone.scale.y, targetData.scale.y, speed * deltaTime);",
            "                                    bone.scale.z = lerp(bone.scale.z, targetData.scale.z, speed * deltaTime);",
            "                                }",
            "                            }",
            "                        });",
            "                    }",
            "                });",
            "",
            "                if (!allPositionsReached) {",
            "                    node.userData.currentState = `${targetDataKey}_active`;",
            "                    node.userData[targetDataKey].reached = false;",
            "",
            "                    // Increment the speed towards speedEnd",
            "                    speed += (speedEnd - speedStart) * deltaTime;",
            "",
            "                    requestAnimationFrame(() => {",
            "                        updateBonePositionsFromUserData(node, deltaTime, animationName, frame, callback);",
            "                    });",
            "                } else {",
            "                    node.userData[targetDataKey].reached = true;",
            "                    node.userData[`${targetDataKey}_reached`] = {",
            "                        position: node.position.clone(),",
            "                        rotation: node.rotation.clone(),",
            "                        scale: node.scale.clone()",
            "                    };",
            "",
            "                    if (targetDataKey === `${animationName}_start`) {",
            "                        obj.setAnimationName(animationName);",
            "                        obj.setAnimationElapsedTime(0);",
            "                        obj.pauseAnimation();",
            "                    } else {",
            "                        obj.setAnimationName(animationName);",
            "                        obj.setAnimationElapsedTime(obj.getAnimationDuration());",
            "                        obj.pauseAnimation();",
            "                    }",
            "",
            "                    node.userData.currentState = `${targetDataKey}_not_active`;",
            "                    node.userData.animationTransition = false;",
            "",
            "                    if (callback) callback();",
            "                }",
            "            }",
            "",
            "            const deltaTime = runtimeScene.getTimeManager().getElapsedTime() / 1000.0;",
            "",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.uuid === pickedName) {",
            "                    if (!node.userData.animationTransition) {",
            "                        node.userData.animationTransition = true;",
            "                        updateBonePositionsFromUserData(node, deltaTime, animationName, frame, () => {",
            "                            isLoopActive = false;",
            "                        });",
            "                    };",
            "                }",
            "            });",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        },
        {
          "description": "Target frame",
          "longDescription": "Pick start or end frame of the animation. The animation will be changed to selected one and paused after finishing the transition",
          "name": "pickFrame",
          "supplementaryInformation": "[\"startFrame\",\"endFrame\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Bones moving start speed",
          "name": "speedStart",
          "type": "expression"
        },
        {
          "description": "Bones moving end speed",
          "name": "speedEnd",
          "type": "expression"
        },
        {
          "description": "indexArgument",
          "longDescription": "Commonly use 0. It depends on your mesh hierarchy - several children of the mesh can be Skinned mesh.",
          "name": "indexArgument",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Is transition in progress",
      "fullName": "Is transition in progress",
      "functionType": "ExpressionAndCondition",
      "name": "IsMovingInProgress",
      "sentence": "Is transition in progress for: _PARAM1_ Animation name: _PARAM2_ Target frame: _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const indexArgument = eventsFunctionContext.getArgument(\"indexArgument\") || 0;",
            "",
            "        if (!scene.userData || !scene.userData[gdName] || !scene.userData[gdName].skinnedMesh) {",
            "            return;",
            "        }",
            "",
            "        const pickedName = scene.userData[gdName].skinnedMesh[indexArgument];",
            "        ",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isMesh && node.uuid === pickedName) {",
            "",
            "                    function checkAnimationState(runtimeScene, object, animationName, frame) {",
            "                        var currentState = node.userData.currentState;",
            "                        var expectedState = `${animationName}_${frame}_active`;",
            "                        ",
            "                        if (currentState === expectedState) {",
            "                            return true;",
            "                        } else {",
            "                            return false;",
            "                        }",
            "                    }",
            "",
            "                    let animationState = false; ",
            "",
            "                    if (node) {",
            "                        animationState = checkAnimationState(",
            "                            runtimeScene,",
            "                            node,",
            "                            eventsFunctionContext.getArgument(\"animationName\"),",
            "                            eventsFunctionContext.getArgument(\"frame\")",
            "                        );",
            "                    }",
            "",
            "                    eventsFunctionContext.returnValue = animationState;",
            "",
            "                }",
            "            });",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "stringWithSelector"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        },
        {
          "description": "Target frame",
          "name": "frame",
          "supplementaryInformation": "[\"start\",\"end\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "indexArgument",
          "name": "indexArgument",
          "type": "expression"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}