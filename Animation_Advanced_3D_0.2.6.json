{
  "author": "",
  "category": "General",
  "extensionNamespace": "",
  "fullName": "Animation system 3d Advanced",
  "helpPath": "https://github.com/GuestGD/Animation_system_3D_Advanced_Gdevelop",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXZpZGVvLW1pbnVzLW91dGxpbmUiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTUgOFYxNkg1VjhIMTVNMTYgNkg0QzMuNDUgNiAzIDYuNDUgMyA3VjE3QzMgMTcuNTUgMy40NSAxOCA0IDE4SDE2QzE2LjU1IDE4IDE3IDE3LjU1IDE3IDE3VjEzLjVMMjEgMTcuNVY2LjVMMTcgMTAuNVY3QzE3IDYuNDUgMTYuNTUgNiAxNiA2TTEzIDEzSDdWMTFIMTNWMTNaIiAvPjwvc3ZnPg==",
  "name": "AnimationAdvanced3D",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/dc34dfac0916a53f58ba6fc06801a4ea79e144b2cc1c200fc07ada8a971ce6b7_video-minus-outline.svg",
  "shortDescription": "Animation system 3d Advanced",
  "version": "0.2",
  "description": [
    "- Make a smooth transition between any mesh animations",
    "- Move between any frames of different animations",
    "- Create bone groups to play several animations simultaneously",
    "- Move any bone",
    "- Find bone names"
  ],
  "tags": [
    "animation 3d transition advanced bones skeleton"
  ],
  "authorIds": [
    "W0yoMQqOeiULIwY1i1Qd8tprOyD2"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "description": "Animation transition",
      "fullName": "Animation transition",
      "functionType": "Action",
      "name": "PlayTransition",
      "sentence": "Animation transition of: _PARAM1_ To animation name: _PARAM2_ Target frame: _PARAM3_ Custom frame: _PARAM4_  Time: _PARAM5_  Bone group: _PARAM6_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function transitionToPose(obj, transitionDuration, boneGroupName) {",
            "  const rendererObject = obj.get3DRendererObject();",
            "  const gdName = obj.getName() + obj.getUniqueId();",
            "  const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "  const animationName = eventsFunctionContext.getArgument(\"animationName\");",
            "  const frame = eventsFunctionContext.getArgument(\"pickFrame\") || \"startFrame\";",
            "  const frameCustom = eventsFunctionContext.getArgument(\"pickFrameCustom\") || 0;",
            "",
            "  if (!threeScene.userData[gdName]) {",
            "    threeScene.userData[gdName] = {};",
            "  }",
            "",
            "  if (!threeScene.userData[gdName].boneGroups) {",
            "    threeScene.userData[gdName].boneGroups = {};",
            "  }",
            "  if (!threeScene.userData[gdName].boneGroups[boneGroupName]) {",
            "    threeScene.userData[gdName].boneGroups[boneGroupName] = {",
            "      currentAnimation: null,",
            "      currentFrame: null,",
            "      animationActive: false,",
            "      bones: [],",
            "      currentAnimationId: null,",
            "      isTransitioning: false",
            "    };",
            "  }",
            "  const boneGroupData = threeScene.userData[gdName].boneGroups[boneGroupName];",
            "  if (!boneGroupData) return;",
            "",
            "  function stopTransition() {",
            "    if (boneGroupData.currentAnimationId !== null) {",
            "      cancelAnimationFrame(boneGroupData.currentAnimationId);",
            "      boneGroupData.currentAnimationId = null;",
            "    }",
            "    boneGroupData.isTransitioning = false;",
            "  }",
            "",
            "  if (boneGroupData.isTransitioning) {",
            "    stopTransition();",
            "    return;",
            "  }",
            "",
            "  rendererObject.traverse((node) => {",
            "    if (node.isSkinnedMesh) {",
            "      const animationsList = obj.getRenderer()._originalModel.animations;",
            "      const animation = animationsList.find(anim => anim.name === animationName);",
            "      if (!animation) {",
            "        return;",
            "      }",
            "",
            "      const boneTracks = animation.tracks.filter(track => track.name.includes('.position') || track.name.includes('.quaternion'));",
            "      const totalFrames = boneTracks[0].times.length || 0;",
            "",
            "      let desiredFrame;",
            "      switch (frame) {",
            "        case \"startFrame\":",
            "          desiredFrame = 0;",
            "          break;",
            "        case \"endFrame\":",
            "          desiredFrame = totalFrames - 1;",
            "          break;",
            "        case \"customFrame\":",
            "          desiredFrame = Math.max(0, Math.min(frameCustom, totalFrames - 1));",
            "          break;",
            "        default:",
            "          desiredFrame = 0;",
            "          break;",
            "      }",
            "",
            "      if (desiredFrame === boneGroupData.currentFrame || (boneGroupData.currentFrame === totalFrames - 1 && desiredFrame >= totalFrames - 1)) {",
            "        return;",
            "      }",
            "",
            "      const initialBoneStates = new Map();",
            "      boneTracks.forEach(track => {",
            "        const boneName = track.name.split('.')[0];",
            "        if (boneGroupData.bones.includes(boneName)) {",
            "          const bone = node.skeleton.bones.find(b => b.name === boneName);",
            "          if (bone) {",
            "            initialBoneStates.set(boneName, {",
            "              position: bone.position.clone(),",
            "              quaternion: bone.quaternion.clone()",
            "            });",
            "          }",
            "        }",
            "      });",
            "",
            "      const targetBoneStates = new Map();",
            "      boneTracks.forEach(track => {",
            "        const boneName = track.name.split('.')[0];",
            "        const trackType = track.name.split('.')[1];",
            "        if (boneGroupData.bones.includes(boneName)) {",
            "          if (trackType === 'position') {",
            "            const valueAtFrame = track.values.slice(desiredFrame * 3, desiredFrame * 3 + 3);",
            "            if (valueAtFrame.length === 3) {",
            "              targetBoneStates.set(boneName, {",
            "                ...targetBoneStates.get(boneName),",
            "                position: new THREE.Vector3(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2])",
            "              });",
            "            }",
            "          } else if (trackType === 'quaternion') {",
            "            const valueAtFrame = track.values.slice(desiredFrame * 4, desiredFrame * 4 + 4);",
            "            if (valueAtFrame.length === 4) {",
            "              targetBoneStates.set(boneName, {",
            "                ...targetBoneStates.get(boneName),",
            "                quaternion: new THREE.Quaternion(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2], valueAtFrame[3])",
            "              });",
            "            }",
            "          }",
            "        }",
            "      });",
            "",
            "      let startTime = null;",
            "      boneGroupData.isTransitioning = true;",
            "",
            "      function animate(currentTime) {",
            "        if (!boneGroupData.isTransitioning) {",
            "          return;",
            "        }",
            "",
            "        if (!startTime) startTime = currentTime;",
            "        const elapsedTime = currentTime - startTime;",
            "        const progress = Math.min(elapsedTime / transitionDuration, 1);",
            "",
            "        boneTracks.forEach(track => {",
            "          const boneName = track.name.split('.')[0];",
            "          if (boneGroupData.bones.includes(boneName)) {",
            "            const bone = node.skeleton.bones.find(b => b.name === boneName);",
            "            if (bone) {",
            "              const initialState = initialBoneStates.get(boneName);",
            "              const targetState = targetBoneStates.get(boneName);",
            "",
            "              if (initialState && targetState) {",
            "                if (initialState.position && targetState.position) {",
            "                  bone.position.lerpVectors(initialState.position, targetState.position, progress);",
            "                }",
            "                if (initialState.quaternion && targetState.quaternion) {",
            "                  bone.quaternion.slerpQuaternions(initialState.quaternion, targetState.quaternion, progress);",
            "                }",
            "              }",
            "            }",
            "          }",
            "        });",
            "",
            "        node.skeleton.update();",
            "",
            "        if (progress < 1) {",
            "          boneGroupData.currentAnimationId = requestAnimationFrame(animate);",
            "        } else {",
            "          boneGroupData.currentAnimation = animationName; ",
            "          boneGroupData.currentFrame = desiredFrame; ",
            "          stopTransition();",
            "        }",
            "      }",
            "",
            "      boneGroupData.currentAnimationId = requestAnimationFrame(animate);",
            "    }",
            "  });",
            "}",
            "",
            "if (objects.length > 0) {",
            "  const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "  objects.forEach(obj => {",
            "    obj.pauseAnimation();",
            "    const speed = eventsFunctionContext.getArgument(\"speed\") * 1000 || 1000;",
            "    const boneGroupName = eventsFunctionContext.getArgument(\"boneGroupName\");",
            "    transitionToPose(obj, speed, boneGroupName);",
            "  });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        },
        {
          "description": "Target frame",
          "longDescription": "Pick start or end frame of the animation. The current animation will be paused and changed to selected one. After the transition is finished the new animation is paused.",
          "name": "pickFrame",
          "supplementaryInformation": "[\"startFrame\",\"endFrame\",\"customFrame\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Pick custom frame",
          "name": "pickFrameCustom",
          "type": "expression"
        },
        {
          "description": "Time in seconds required to reach a target frame",
          "longDescription": "Amount of seconds required to reach a target frame (higher value = slower transition)",
          "name": "speed",
          "type": "expression"
        },
        {
          "description": "Bone group",
          "name": "boneGroupName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Play bone group animation",
      "fullName": "Play bone group animation",
      "functionType": "Action",
      "name": "PlayBoneGroupAnimation",
      "sentence": "Play bone group animation of: _PARAM1_ Animation: _PARAM2_ Bone group: _PARAM3_ Start frame: _PARAM4_  End frame: _PARAM5_  Speed: _PARAM6_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function playAnimationForBoneGroup(obj, animationName, boneGroup, startFrame, endFrame, speed) {",
            "  const rendererObject = obj.get3DRendererObject();",
            "  const gdName = obj.getName() + obj.getUniqueId();",
            "  const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "",
            "  if (!threeScene.userData[gdName]) {",
            "    threeScene.userData[gdName] = {};",
            "  }",
            "  if (!threeScene.userData[gdName].animation) {",
            "    threeScene.userData[gdName].animation = {};",
            "  }",
            "  const animationData = threeScene.userData[gdName].animation;",
            "",
            "  rendererObject.traverse((node) => {",
            "    if (node.isSkinnedMesh) {",
            "      const animationsList = obj.getRenderer()._originalModel.animations;",
            "      const animation = animationsList.find(anim => anim.name === animationName);",
            "      if (!animation) return;",
            "",
            "      const boneTracks = animation.tracks.filter(track => track.name.includes('.position') || track.name.includes('.quaternion'));",
            "      const totalFrames = boneTracks[0].times.length || 0;",
            "",
            "      startFrame = Math.max(0, Math.min(startFrame, totalFrames - 1));",
            "      endFrame = Math.max(0, Math.min(endFrame, totalFrames - 1));",
            "",
            "      if (!threeScene.userData[gdName].boneGroups) {",
            "        threeScene.userData[gdName].boneGroups = {};",
            "      }",
            "      if (!threeScene.userData[gdName].boneGroups[boneGroup]) {",
            "        threeScene.userData[gdName].boneGroups[boneGroup] = {",
            "          currentAnimation: null,",
            "          currentFrame: null,",
            "          animationActive: false,",
            "          bones: [],",
            "          currentAnimationId: null,",
            "          isTransitioning: false",
            "        };",
            "      }",
            "      const boneGroupData = threeScene.userData[gdName].boneGroups[boneGroup];",
            "      if (!boneGroupData) return;",
            "",
            "      let startTime = null;",
            "      let currentFrame = startFrame;",
            "      const frameDuration = (endFrame - startFrame) / (speed * 60);",
            "",
            "      function animate(currentTime) {",
            "        if (!startTime) startTime = currentTime;",
            "        const elapsedTime = currentTime - startTime;",
            "        const progress = Math.min(elapsedTime / (speed * 1000), 1);",
            "",
            "        if (!boneGroupData.animationActive) {",
            "          return;",
            "        }",
            "",
            "        boneTracks.forEach(track => {",
            "          const boneName = track.name.split('.')[0];",
            "          if (boneGroupData.bones.includes(boneName)) {",
            "            const bone = node.skeleton.bones.find(b => b.name === boneName);",
            "            if (bone) {",
            "              const trackType = track.name.split('.')[1];",
            "              currentFrame = startFrame + Math.floor(progress * (endFrame - startFrame));",
            "              if (trackType === 'position') {",
            "                const valueAtFrame = track.values.slice(currentFrame * 3, currentFrame * 3 + 3);",
            "                if (valueAtFrame.length === 3) {",
            "                  bone.position.set(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2]);",
            "                }",
            "              } else if (trackType === 'quaternion') {",
            "                const valueAtFrame = track.values.slice(currentFrame * 4, currentFrame * 4 + 4);",
            "                if (valueAtFrame.length === 4) {",
            "                  bone.quaternion.set(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2], valueAtFrame[3]);",
            "                }",
            "              }",
            "            }",
            "          }",
            "        });",
            "",
            "        node.skeleton.update();",
            "",
            "        boneGroupData.currentFrame = currentFrame;",
            "",
            "        if (progress < 1) {",
            "          requestAnimationFrame(animate);",
            "        } else {",
            "          animationData[animationName] = endFrame;",
            "          animationData.currentFrame = endFrame;",
            "          boneGroupData.currentAnimation = animationName;",
            "          boneGroupData.currentFrame = endFrame;",
            "          boneGroupData.animationActive = false;",
            "        }",
            "      }",
            "",
            "      if (threeScene.userData[gdName].animation[boneGroup]) {",
            "        cancelAnimationFrame(threeScene.userData[gdName].animation[boneGroup]);",
            "        threeScene.userData[gdName].animation[boneGroup] = null;",
            "      }",
            "",
            "      boneGroupData.currentAnimation = animationName;",
            "      boneGroupData.currentFrame = startFrame;",
            "      boneGroupData.animationActive = true;",
            "",
            "      threeScene.userData[gdName].animation[boneGroup] = requestAnimationFrame(animate);",
            "    }",
            "  });",
            "}",
            "",
            "if (objects.length > 0) {",
            "  const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "  objects.forEach(obj => {",
            "    const animationName = eventsFunctionContext.getArgument(\"animationName\");",
            "    const boneGroupName = eventsFunctionContext.getArgument(\"boneGroupName\");",
            "    const startFrame = eventsFunctionContext.getArgument(\"startFrame\") || 0;",
            "    const endFrame = eventsFunctionContext.getArgument(\"endFrame\") || 0;",
            "    const speed = eventsFunctionContext.getArgument(\"speed\") || 1;",
            "    playAnimationForBoneGroup(obj, animationName, boneGroupName, startFrame, endFrame, speed);",
            "  });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        },
        {
          "description": "boneGroupName",
          "name": "boneGroupName",
          "type": "string"
        },
        {
          "description": "startFrame",
          "longDescription": "Pick any frame to start animation from",
          "name": "startFrame",
          "supplementaryInformation": "[\"startFrame\",\"endFrame\"]",
          "type": "expression"
        },
        {
          "description": "endFrame",
          "longDescription": "Pick any frame to end animation at",
          "name": "endFrame",
          "type": "expression"
        },
        {
          "description": "Bones moving speed",
          "name": "speed",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Is transition in progress",
      "fullName": "Is transition in progress",
      "functionType": "ExpressionAndCondition",
      "name": "IsMovingInProgress",
      "sentence": "Is transition in progress for: _PARAM1_ Bone group: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const boneGroup = eventsFunctionContext.getArgument(\"boneGroup\");",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "        ",
            "        if (!threeScene.userData[gdName].boneGroups) {",
            "            threeScene.userData[gdName].boneGroups = {};",
            "        }",
            "",
            "        if (!threeScene.userData[gdName].boneGroups[boneGroup]) {",
            "            threeScene.userData[gdName].boneGroups[boneGroup] = {",
            "                currentAnimation: null,",
            "                currentFrame: null,",
            "                animationActive: false,",
            "                bones: [],",
            "                currentAnimationId: null,",
            "                isTransitioning: false",
            "            };",
            "        }",
            "",
            "        const transitionData = threeScene.userData[gdName].boneGroups[boneGroup].isTransitioning;",
            "        eventsFunctionContext.returnValue = transitionData;",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "stringWithSelector"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Bone group",
          "name": "boneGroup",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Animation name of bone group",
      "fullName": "Animation name of bone group",
      "functionType": "ExpressionAndCondition",
      "name": "IsAnimationName",
      "sentence": "Animation name of: _PARAM1_ Bone group: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const boneGroup = eventsFunctionContext.getArgument(\"boneGroup\");",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "",
            "        if (!threeScene.userData[gdName].boneGroups) {",
            "            threeScene.userData[gdName].boneGroups = {};",
            "        }",
            "",
            "        if (!threeScene.userData[gdName].boneGroups[boneGroup]) {",
            "            threeScene.userData[gdName].boneGroups[boneGroup] = {",
            "                currentAnimation: null,",
            "                currentFrame: null,",
            "                animationActive: false,",
            "                bones: [],",
            "                currentAnimationId: null,",
            "                isTransitioning: false",
            "            };",
            "        }",
            "        const animationData = threeScene.userData[gdName].boneGroups[boneGroup].currentAnimation;",
            "",
            "        eventsFunctionContext.returnValue = animationData;",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\"]",
        "type": "string"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Bone group",
          "name": "boneGroup",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Animation frame of bone group",
      "fullName": "Animation frame of bone group",
      "functionType": "ExpressionAndCondition",
      "name": "IsAnimationFrame",
      "sentence": "Animation frame of: _PARAM1_ Bone group: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const boneGroup = eventsFunctionContext.getArgument(\"boneGroup\");",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "",
            "        if (!threeScene.userData[gdName].boneGroups) {",
            "            threeScene.userData[gdName].boneGroups = {};",
            "        }",
            "",
            "        if (!threeScene.userData[gdName].boneGroups[boneGroup]) {",
            "            threeScene.userData[gdName].boneGroups[boneGroup] = {",
            "                currentAnimation: null,",
            "                currentFrame: null,",
            "                animationActive: false,",
            "                bones: [],",
            "                currentAnimationId: null,",
            "                isTransitioning: false",
            "            };",
            "        }",
            "        const animationData = threeScene.userData[gdName].boneGroups[boneGroup].currentFrame;",
            "",
            "        eventsFunctionContext.returnValue = animationData;",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "supplementaryInformation": "object",
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Bone group",
          "name": "boneGroup",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Animation of bone group is active",
      "fullName": "Animation of bone group is active",
      "functionType": "ExpressionAndCondition",
      "name": "IsAnimationActive",
      "sentence": "Current animation of: _PARAM1_ Bone group: _PARAM2_ Active",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const boneGroup = eventsFunctionContext.getArgument(\"boneGroup\");",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "",
            "        if (!threeScene.userData[gdName].boneGroups) {",
            "            threeScene.userData[gdName].boneGroups = {};",
            "        }",
            "",
            "        if (!threeScene.userData[gdName].boneGroups[boneGroup]) {",
            "            threeScene.userData[gdName].boneGroups[boneGroup] = {",
            "                currentAnimation: null,",
            "                currentFrame: null,",
            "                animationActive: false,",
            "                bones: [],",
            "                currentAnimationId: null,",
            "                isTransitioning: false",
            "            };",
            "        }",
            "        const animationData = threeScene.userData[gdName].boneGroups[boneGroup].animationActive;",
            "",
            "        if (animationData === true) {",
            "            eventsFunctionContext.returnValue = true;",
            "        } else {",
            "            eventsFunctionContext.returnValue = false;",
            "        }",
            "        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "stringWithSelector"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Bone group",
          "name": "boneGroup",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Max frames amount",
      "fullName": "Max frames amount",
      "functionType": "ExpressionAndCondition",
      "name": "IsMaxFrameAmount",
      "sentence": "Max frames amount for: _PARAM1_ Animation name: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const animationName = eventsFunctionContext.getArgument(\"animationName\");",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "",
            "        const animationsList = obj.getRenderer()._originalModel.animations;",
            "        const animation = animationsList.find(anim => anim.name === animationName);",
            "        if (!animation) {",
            "            return;",
            "        }",
            "",
            "        const boneTracks = animation.tracks.filter(track => track.name.includes('.position') || track.name.includes('.quaternion'));",
            "        const totalFrames = (boneTracks[0].times.length)-1 || 0;",
            "        eventsFunctionContext.returnValue = totalFrames;",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show all bone names",
      "fullName": "Show all bone names",
      "functionType": "StringExpression",
      "group": "Bones",
      "name": "ShowAllBoneNamesExpression",
      "sentence": "Show all bone names for:  _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    const bonesList = [];",
            "                    node.skeleton.bones.forEach((bone) => {",
            "                        bonesList.push(bone.name);           ",
            "                    });",
            "                    const bonesListString = bonesList.join(',');",
            "                    eventsFunctionContext.returnValue = bonesListString;",
            "                }",
            "            });             ",
            "        }        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show bones including names",
      "fullName": "Show bones including names",
      "functionType": "StringExpression",
      "group": "Bones",
      "name": "ShowBoneIncludedCharsExpression",
      "sentence": "Show bones including names (DEBUG console) for:  _PARAM1_ Names: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const boneNamesToSearch = eventsFunctionContext.getArgument(\"boneNamesToSearch\").split(',').map(name => name.trim().toLowerCase());",
            "",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    const bonesList = [];",
            "                    node.skeleton.bones.forEach((bone) => {",
            "                        const boneNameLower = bone.name.toLowerCase();",
            "                        const shouldInclude = boneNamesToSearch.some(searchName => {",
            "                            if (searchName.endsWith('*')) {",
            "                                const baseName = searchName.slice(0, -1);",
            "                                const index = boneNameLower.indexOf(baseName);",
            "                                return index !== -1 && (index + baseName.length === boneNameLower.length || !boneNameLower[index + baseName.length].match(/[a-z0-9]/i));",
            "                            } else {",
            "                                return boneNameLower.includes(searchName);",
            "                            }",
            "                        });",
            "                        if (shouldInclude) {",
            "                            bonesList.push(bone.name);",
            "                        }",
            "                    });",
            "                    const bonesListString = bonesList.join(',');",
            "                    eventsFunctionContext.returnValue = bonesListString;",
            "                }",
            "            });",
            "        }",
            "    });",
            "}",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Array of names",
          "longDescription": "Example: if a mesh has bones  \"LegBoneUp\",  \"LegBoneLow\" and you write \"leg\" here all bones with \"Leg\" or \"leg\" will be shown. Use \"*\" to ignore names that contains anything after a word -\"leg*\" gonna show \"upLeg, middleLeg\" but will ignore \"middleLeg2\"",
          "name": "boneNamesToSearch",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show bone names (DEBUG console)",
      "fullName": "Show bone names (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowBoneNames",
      "sentence": "Show bone names (DEBUG console) for:  _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    const bonesList = [];",
            "                    node.skeleton.bones.forEach((bone) => {",
            "                        bonesList.push(bone.name);           ",
            "                    });",
            "                    const bonesListString = bonesList.join(',');",
            "                    console.log(`Bones of ${gdName} with uuid ${node.uuid} : ${bonesListString}`);",
            "                }",
            "            });             ",
            "        }        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show bones including names (DEBUG console)",
      "fullName": "Show bones including names (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowBoneIncludedChars",
      "sentence": "Show bones including names (DEBUG console) for:  _PARAM1_ Names: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const boneNamesToSearch = eventsFunctionContext.getArgument(\"boneNamesToSearch\").split(',').map(name => name.trim().toLowerCase());",
            "",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    const bonesList = [];",
            "                    node.skeleton.bones.forEach((bone) => {",
            "                        const boneNameLower = bone.name.toLowerCase();",
            "                        if (boneNamesToSearch.some(searchName => boneNameLower.includes(searchName))) {",
            "                            bonesList.push(bone.name);",
            "                        }",
            "                    });",
            "                    const bonesListString = bonesList.join(',');",
            "                    console.log(`Bones of ${gdName} with uuid ${node.uuid} : ${bonesListString}`);",
            "                }",
            "            });             ",
            "        }        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Array of names",
          "longDescription": "Example: if a mesh has bones  \"LegBoneUp\",  \"LegBoneLow\" and you write \"leg\" here all bones with \"Leg\" or \"leg\" will be shown",
          "name": "boneNamesToSearch",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show all bone groups (DEBUG console)",
      "fullName": "Show all bone groups (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowAllBoneGroups",
      "sentence": "Show all bone groups (DEBUG console) for:  _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    if (!scene.userData || !scene.userData[gdName] || !scene.userData[gdName].boneGroups ) {",
            "                        return;",
            "                    }",
            "",
            "                    console.log(`All bone groups of ${JSON.stringify(gdName)} :  ${JSON.stringify(scene.userData[gdName].boneGroups)}`)",
            "                }",
            "            });             ",
            "        }",
            "        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show animations list (DEBUG console)",
      "fullName": "Show animations list (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowAnimationsList",
      "sentence": "Show animations list (DEBUG console) for:  _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh) {",
            "                    const animations = obj._animations;",
            "                    if (animations.length === 0) {",
            "                        return;",
            "                    }",
            "",
            "                    console.log(`Animations of ${JSON.stringify(gdName)} :  ${JSON.stringify(animations)}`)",
            "                }",
            "            });             ",
            "        }",
            "        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show a bone group's bones (DEBUG console)",
      "fullName": "Show a bone group's bones (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowBoneGroupBones",
      "sentence": "Show a bone group's bones (DEBUG console) for:  _PARAM1_ Group name: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const groupName = eventsFunctionContext.getArgument(\"groupName\");",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    if (!scene.userData || !scene.userData[gdName] || !scene.userData[gdName].boneGroups ) {",
            "                        return;",
            "                    }",
            "                    const boneGroup = scene.userData[gdName].boneGroups[groupName].bones;",
            "                    const bonesListString = boneGroup.join(',');",
            "                    if (bonesListString.length > 0) {",
            "                        console.log(`Bone group bones of ${JSON.stringify(gdName)} for group name ${JSON.stringify(groupName)} :  ${JSON.stringify(bonesListString)}`)",
            "                    }",
            "                }",
            "            });             ",
            "        }        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Bone group name",
          "name": "groupName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Create bone group",
      "fullName": "Create bone group",
      "functionType": "Action",
      "name": "CreateBoneGroup",
      "sentence": "Create bone group for:  _PARAM1_ Bone names: _PARAM2_ Bone group name: _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const boneNames = eventsFunctionContext.getArgument(\"boneNames\").replace(/\\s+/g, '').split(',');",
            "    const boneGroupName = eventsFunctionContext.getArgument(\"groupName\");",
            "",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const bonesList = [];",
            "",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh) {",
            "                    node.skeleton.bones.forEach((bone) => {",
            "                        if (boneNames.includes(bone.name) && !bonesList.includes(bone.name)) {",
            "                            bonesList.push(bone.name);",
            "                        }",
            "                    });",
            "                }",
            "            });",
            "        }",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "        if (!threeScene.userData[gdName].boneGroups) {",
            "            threeScene.userData[gdName].boneGroups = {};",
            "        }",
            "        if (!threeScene.userData[gdName].boneGroups[boneGroupName]) {",
            "            threeScene.userData[gdName].boneGroups[boneGroupName] = { bones: [] };",
            "        }",
            "",
            "        bonesList.forEach(boneName => {",
            "            if (!threeScene.userData[gdName].boneGroups[boneGroupName].bones.includes(boneName)) {",
            "                threeScene.userData[gdName].boneGroups[boneGroupName].bones.push(boneName);",
            "            }",
            "        });",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Bone names list ",
          "longDescription": "\"bone1,bone2,bone3...\"",
          "name": "boneNames",
          "type": "string"
        },
        {
          "description": "Group name",
          "name": "groupName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Bone group exists",
      "fullName": "Bone group exists",
      "functionType": "ExpressionAndCondition",
      "name": "IsBoneGroupExist",
      "sentence": "Bone group exists for:  _PARAM1_ Bone group name: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const boneGroupName = eventsFunctionContext.getArgument(\"groupName\");",
            "",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "        if (!threeScene.userData[gdName].boneGroups) {",
            "            threeScene.userData[gdName].boneGroups = {};",
            "        }",
            "        if (!threeScene.userData[gdName].boneGroups[boneGroupName]) {",
            "            threeScene.userData[gdName].boneGroups[boneGroupName] = { bones: [] };",
            "        }",
            "",
            "        const boneGroupLength = threeScene.userData[gdName].boneGroups[boneGroupName].bones;",
            "",
            "        if (boneGroupLength.length > 0) {",
            "            eventsFunctionContext.returnValue = true;",
            "        } else {",
            "            eventsFunctionContext.returnValue = false;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "stringWithSelector"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Group name",
          "name": "groupName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Stop bone group animation",
      "fullName": "Stop bone group animation",
      "functionType": "Action",
      "name": "StopBoneGroupAnimation",
      "sentence": "Stop bone group animation for:  _PARAM1_ Bone group name: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const boneGroupName = eventsFunctionContext.getArgument(\"groupName\");",
            "",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "",
            "        if (threeScene.userData[gdName] && threeScene.userData[gdName].boneGroups && threeScene.userData[gdName].boneGroups[boneGroupName]) {",
            "            threeScene.userData[gdName].boneGroups[boneGroupName].animationActive = false;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Group name",
          "name": "groupName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Rotate bone",
      "fullName": "Rotate bone",
      "functionType": "Action",
      "name": "RotateBone",
      "sentence": "Rotate bone of: _PARAM1_ Bone name: _PARAM2_ Axis: _PARAM3_ Operator: _PARAM4_ Value: _PARAM5_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {\r",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();\r",
            "    const targetBone = eventsFunctionContext.getArgument(\"targetBone\");\r",
            "\r",
            "    const axis = eventsFunctionContext.getArgument(\"axis\");\r",
            "    const operator = eventsFunctionContext.getArgument(\"operator\");\r",
            "    const value = THREE.MathUtils.degToRad(eventsFunctionContext.getArgument(\"value\"));\r",
            "\r",
            "    objects.forEach((obj, index) => {\r",
            "        const gdName = obj.getName() + obj.getUniqueId();\r",
            "        const rendererObject = obj.get3DRendererObject();\r",
            "        if (rendererObject) {\r",
            "            rendererObject.traverse((node) => {\r",
            "                if (node.isBone && node.name === targetBone) {\r",
            "                    let targetAxis;\r",
            "                    switch (axis) {\r",
            "                        case \"x\":\r",
            "                            targetAxis = \"x\";\r",
            "                            break;\r",
            "\r",
            "                        case \"y\":\r",
            "                            targetAxis = \"y\";\r",
            "                            break;\r",
            "\r",
            "                        case \"z\":\r",
            "                            targetAxis = \"z\";\r",
            "                            break;\r",
            "                    }\r",
            "\r",
            "\r",
            "\r",
            "                    switch (operator) {\r",
            "                        case \"=\":\r",
            "                            node.rotation[axis] = value;\r",
            "                            break;\r",
            "\r",
            "                        case \"+\":\r",
            "                            node.rotation[axis] += value;\r",
            "                            break;\r",
            "\r",
            "                        case \"-\":\r",
            "                            node.rotation[axis] -= value;\r",
            "                            break;\r",
            "                    }\r",
            "                     \r",
            "                }\r",
            "            })\r",
            "        }\r",
            "    })\r",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "targetBone",
          "name": "targetBone",
          "type": "string"
        },
        {
          "description": "axis",
          "name": "axis",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Operator",
          "name": "operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Value",
          "name": "value",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Move bone",
      "fullName": "Move bone",
      "functionType": "Action",
      "name": "MoveBone",
      "sentence": "Move bone of: _PARAM1_ Bone name: _PARAM2_ Axis: _PARAM3_ Operator: _PARAM4_ Value: _PARAM5_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {\r",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();\r",
            "    const targetBone = eventsFunctionContext.getArgument(\"targetBone\");\r",
            "\r",
            "    const axis = eventsFunctionContext.getArgument(\"axis\");\r",
            "    const operator = eventsFunctionContext.getArgument(\"operator\");\r",
            "    const value = (eventsFunctionContext.getArgument(\"value\"));\r",
            "\r",
            "    objects.forEach((obj, index) => {\r",
            "        const gdName = obj.getName() + obj.getUniqueId();\r",
            "        const rendererObject = obj.get3DRendererObject();\r",
            "        if (rendererObject) {\r",
            "            rendererObject.traverse((node) => {\r",
            "                if (node.isBone && node.name === targetBone) {\r",
            "                    let targetAxis;\r",
            "                    switch (axis) {\r",
            "                        case \"x\":\r",
            "                            targetAxis = \"x\";\r",
            "                            break;\r",
            "\r",
            "                        case \"y\":\r",
            "                            targetAxis = \"y\";\r",
            "                            break;\r",
            "\r",
            "                        case \"z\":\r",
            "                            targetAxis = \"z\";\r",
            "                            break;\r",
            "                    }\r",
            "\r",
            "\r",
            "\r",
            "                    switch (operator) {\r",
            "                        case \"=\":\r",
            "                            node.position[axis] = value;\r",
            "                            break;\r",
            "\r",
            "                        case \"+\":\r",
            "                            node.position[axis] += value;\r",
            "                            break;\r",
            "\r",
            "                        case \"-\":\r",
            "                            node.position[axis] -= value;\r",
            "                            break;\r",
            "                    }\r",
            "                     \r",
            "                }\r",
            "            })\r",
            "        }\r",
            "    })\r",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "targetBone",
          "name": "targetBone",
          "type": "string"
        },
        {
          "description": "axis",
          "name": "axis",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Operator",
          "name": "operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Value",
          "name": "value",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Scale bone",
      "fullName": "Scale bone",
      "functionType": "Action",
      "name": "ScaleBone",
      "sentence": "Scale bone of: _PARAM1_ Bone name: _PARAM2_ Axis: _PARAM3_ Operator: _PARAM4_ Value: _PARAM5_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {\r",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();\r",
            "    const targetBone = eventsFunctionContext.getArgument(\"targetBone\");\r",
            "\r",
            "    const axis = eventsFunctionContext.getArgument(\"axis\");\r",
            "    const operator = eventsFunctionContext.getArgument(\"operator\");\r",
            "    const value = (eventsFunctionContext.getArgument(\"value\"));\r",
            "\r",
            "    objects.forEach((obj, index) => {\r",
            "        const gdName = obj.getName() + obj.getUniqueId();\r",
            "        const rendererObject = obj.get3DRendererObject();\r",
            "        if (rendererObject) {\r",
            "            rendererObject.traverse((node) => {\r",
            "                if (node.isBone && node.name === targetBone) {\r",
            "                    let targetAxis;\r",
            "                    switch (axis) {\r",
            "                        case \"x\":\r",
            "                            targetAxis = \"x\";\r",
            "                            break;\r",
            "\r",
            "                        case \"y\":\r",
            "                            targetAxis = \"y\";\r",
            "                            break;\r",
            "\r",
            "                        case \"z\":\r",
            "                            targetAxis = \"z\";\r",
            "                            break;\r",
            "                    }\r",
            "\r",
            "\r",
            "\r",
            "                    switch (operator) {\r",
            "                        case \"=\":\r",
            "                            node.scale[axis] = value;\r",
            "                            break;\r",
            "\r",
            "                        case \"+\":\r",
            "                            node.scale[axis] += value;\r",
            "                            break;\r",
            "\r",
            "                        case \"-\":\r",
            "                            node.scale[axis] -= value;\r",
            "                            break;\r",
            "                    }\r",
            "                     \r",
            "                }\r",
            "            })\r",
            "        }\r",
            "    })\r",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "targetBone",
          "name": "targetBone",
          "type": "string"
        },
        {
          "description": "axis",
          "name": "axis",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Operator",
          "name": "operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Value",
          "name": "value",
          "type": "expression"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}