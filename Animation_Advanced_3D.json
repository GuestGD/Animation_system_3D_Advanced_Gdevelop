{
  "author": "",
  "category": "General",
  "extensionNamespace": "",
  "fullName": "Animation system 3d Advanced",
  "helpPath": "https://github.com/GuestGD/Animation_system_3D_Advanced_Gdevelop",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXZpZGVvLW1pbnVzLW91dGxpbmUiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTUgOFYxNkg1VjhIMTVNMTYgNkg0QzMuNDUgNiAzIDYuNDUgMyA3VjE3QzMgMTcuNTUgMy40NSAxOCA0IDE4SDE2QzE2LjU1IDE4IDE3IDE3LjU1IDE3IDE3VjEzLjVMMjEgMTcuNVY2LjVMMTcgMTAuNVY3QzE3IDYuNDUgMTYuNTUgNiAxNiA2TTEzIDEzSDdWMTFIMTNWMTNaIiAvPjwvc3ZnPg==",
  "name": "AnimationTransition3D",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/dc34dfac0916a53f58ba6fc06801a4ea79e144b2cc1c200fc07ada8a971ce6b7_video-minus-outline.svg",
  "shortDescription": "Animation system 3d Advanced",
  "version": "0.2",
  "description": [
    "- Make a smooth transition between any mesh animations",
    "- Move between any frames of different animations",
    "- Create bone groups to play several animations simultaneously",
    "- Move any bone",
    "- Find bone names"
  ],
  "tags": [
    "animation 3d transition advanced bones skeleton"
  ],
  "authorIds": [
    "W0yoMQqOeiULIwY1i1Qd8tprOyD2"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "description": "Play animation by name",
      "fullName": "Play animation by name",
      "functionType": "Action",
      "name": "Play",
      "private": true,
      "sentence": "Play animation by name for: _PARAM1_ Animation name: _PARAM2_ Speed: _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length >0) {",
            "    const objectName = objects[0].getName();",
            "    const animationName = eventsFunctionContext.getArgument(\"animationName\"); ",
            "    const speedScale = eventsFunctionContext.getArgument(\"playSpeed\"); ",
            "",
            "    const object = runtimeScene.getObjects(objectName)[0];",
            "",
            "    if (object && object instanceof gdjs.Model3DRuntimeObject) {",
            "        const currentSpeed = object.getAnimationSpeedScale();",
            "",
            "        const renderer = object.getRenderer();",
            "        const isEnded = renderer.hasAnimationEnded();",
            "        if (renderer.hasAnimationEnded()) {",
            "            if (currentSpeed !== speedScale) {",
            "                object.setAnimationSpeedScale(speedScale);",
            "            }",
            "            object.setAnimationElapsedTime(0)",
            "            renderer.playAnimation(animationName);",
            "        }",
            "    }",
            "",
            "};",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        },
        {
          "description": "Speed of animation",
          "name": "playSpeed",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Animation transition",
      "fullName": "Animation transition",
      "functionType": "Action",
      "name": "PlayTransition",
      "sentence": "Animation transition of: _PARAM1_ To animation name: _PARAM2_ Target frame: _PARAM3_ Custom frame: _PARAM4_  Time: _PARAM5_  ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function transitionToPose(obj, transitionDuration) {",
            "  const rendererObject = obj.get3DRendererObject();",
            "  const gdName = obj.getName() + obj.getUniqueId();",
            "  const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "  const animationName = eventsFunctionContext.getArgument(\"animationName\");",
            "  const frame = eventsFunctionContext.getArgument(\"pickFrame\") || \"startFrame\";",
            "  const frameCustom = eventsFunctionContext.getArgument(\"pickFrameCustom\") || 0;",
            "",
            "  if (!threeScene.userData[gdName]) {",
            "    threeScene.userData[gdName] = {};",
            "  }",
            "  if (!threeScene.userData[gdName].transition) {",
            "    threeScene.userData[gdName].transition = {",
            "      currentAnimationId: null,",
            "      isTransitioning: false",
            "    };",
            "  }",
            "  if (!threeScene.userData[gdName].animation) {",
            "    threeScene.userData[gdName].animation = {",
            "      currentFrame: null,",
            "      animationName: null ",
            "    };",
            "  }",
            "  const transitionData = threeScene.userData[gdName].transition;",
            "  const animationData = threeScene.userData[gdName].animation;",
            "",
            "  animationData.animationName = animationName;",
            "",
            "  function stopTransition() {",
            "    if (transitionData.currentAnimationId !== null) {",
            "      cancelAnimationFrame(transitionData.currentAnimationId);",
            "      transitionData.currentAnimationId = null;",
            "    }",
            "    transitionData.isTransitioning = false;",
            "  }",
            "",
            "  if (transitionData.isTransitioning) {",
            "    stopTransition();",
            "    return;",
            "  }",
            "",
            "  rendererObject.traverse((node) => {",
            "    if (node.isSkinnedMesh) {",
            "      const animationsList = obj.getRenderer()._originalModel.animations;",
            "      const animation = animationsList.find(anim => anim.name === animationName);",
            "      if (!animation) {",
            "        return;",
            "      }",
            "",
            "      const boneTracks = animation.tracks.filter(track => track.name.includes('.position') || track.name.includes('.quaternion'));",
            "      const totalFrames = boneTracks[0].times.length || 0;",
            "",
            "      let desiredFrame;",
            "      switch (frame) {",
            "        case \"startFrame\":",
            "          desiredFrame = 0;",
            "          break;",
            "        case \"endFrame\":",
            "          desiredFrame = totalFrames - 1;",
            "          break;",
            "        case \"customFrame\":",
            "          desiredFrame = Math.max(0, Math.min(frameCustom, totalFrames - 1));",
            "          break;",
            "        default:",
            "          desiredFrame = 0;",
            "          break;",
            "      }",
            "",
            "      if (desiredFrame === animationData.currentFrame || (animationData.currentFrame === totalFrames - 1 && desiredFrame >= totalFrames - 1)) {",
            "        return;",
            "      }",
            "",
            "      const initialBoneStates = new Map();",
            "      boneTracks.forEach(track => {",
            "        const boneName = track.name.split('.')[0];",
            "        const bone = node.skeleton.bones.find(b => b.name === boneName);",
            "        if (bone) {",
            "          initialBoneStates.set(boneName, {",
            "            position: bone.position.clone(),",
            "            quaternion: bone.quaternion.clone()",
            "          });",
            "        }",
            "      });",
            "",
            "      const targetBoneStates = new Map();",
            "      boneTracks.forEach(track => {",
            "        const boneName = track.name.split('.')[0];",
            "        const trackType = track.name.split('.')[1];",
            "        if (trackType === 'position') {",
            "          const valueAtFrame = track.values.slice(desiredFrame * 3, desiredFrame * 3 + 3);",
            "          if (valueAtFrame.length === 3) {",
            "            targetBoneStates.set(boneName, {",
            "              ...targetBoneStates.get(boneName),",
            "              position: new THREE.Vector3(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2])",
            "            });",
            "          }",
            "        } else if (trackType === 'quaternion') {",
            "          const valueAtFrame = track.values.slice(desiredFrame * 4, desiredFrame * 4 + 4);",
            "          if (valueAtFrame.length === 4) {",
            "            targetBoneStates.set(boneName, {",
            "              ...targetBoneStates.get(boneName),",
            "              quaternion: new THREE.Quaternion(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2], valueAtFrame[3])",
            "            });",
            "          }",
            "        }",
            "      });",
            "",
            "      let startTime = null;",
            "      transitionData.isTransitioning = true;",
            "",
            "      function animate(currentTime) {",
            "        if (!transitionData.isTransitioning) {",
            "          return;",
            "        }",
            "",
            "        if (!startTime) startTime = currentTime;",
            "        const elapsedTime = currentTime - startTime;",
            "        const progress = Math.min(elapsedTime / transitionDuration, 1);",
            "",
            "        boneTracks.forEach(track => {",
            "          const boneName = track.name.split('.')[0];",
            "          const bone = node.skeleton.bones.find(b => b.name === boneName);",
            "          if (bone) {",
            "            const initialState = initialBoneStates.get(boneName);",
            "            const targetState = targetBoneStates.get(boneName);",
            "",
            "            if (initialState && targetState) {",
            "              if (initialState.position && targetState.position) {",
            "                bone.position.lerpVectors(initialState.position, targetState.position, progress);",
            "              }",
            "              if (initialState.quaternion && targetState.quaternion) {",
            "                bone.quaternion.slerpQuaternions(initialState.quaternion, targetState.quaternion, progress);",
            "              }",
            "            }",
            "          }",
            "        });",
            "",
            "        node.skeleton.update();",
            "",
            "        if (progress < 1) {",
            "          transitionData.currentAnimationId = requestAnimationFrame(animate);",
            "        } else {",
            "          animationData.currentFrame = desiredFrame;",
            "          stopTransition();",
            "        }",
            "      }",
            "",
            "      transitionData.currentAnimationId = requestAnimationFrame(animate);",
            "    }",
            "  });",
            "}",
            "",
            "if (objects.length > 0) {",
            "  const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "  objects.forEach(obj => {",
            "    obj.pauseAnimation();",
            "    const speed = eventsFunctionContext.getArgument(\"speed\") * 1000 || 1000;",
            "    transitionToPose(obj, speed);",
            "  });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        },
        {
          "description": "Target frame",
          "longDescription": "Pick start or end frame of the animation. The current animation will be paused and changed to selected one. After the transition is finished the new animation is paused.",
          "name": "pickFrame",
          "supplementaryInformation": "[\"startFrame\",\"endFrame\",\"customFrame\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Pick custom frame",
          "name": "pickFrameCustom",
          "type": "expression"
        },
        {
          "description": "Time in seconds required to reach a target frame",
          "longDescription": "Amount of seconds required to reach a target frame (higher value = slower transition)",
          "name": "speed",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Play bone group animation",
      "fullName": "Play bone group animation",
      "functionType": "Action",
      "name": "PlayBoneGroupAnimation",
      "sentence": "Play bone group animation of: _PARAM1_ Animation: _PARAM2_ Bone group: _PARAM3_ Start frame: _PARAM4_  End frame: _PARAM5_  Speed: _PARAM6_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function playAnimationForBoneGroup(obj, animationName, boneGroupName, startFrame, endFrame, speed) {",
            "  const rendererObject = obj.get3DRendererObject();",
            "  const gdName = obj.getName() + obj.getUniqueId();",
            "  const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "",
            "  if (!threeScene.userData[gdName]) {",
            "    threeScene.userData[gdName] = {};",
            "  }",
            "  if (!threeScene.userData[gdName].animation) {",
            "    threeScene.userData[gdName].animation = {};",
            "  }",
            "  const animationData = threeScene.userData[gdName].animation;",
            "",
            "  rendererObject.traverse((node) => {",
            "    if (node.isSkinnedMesh) {",
            "      const animationsList = obj.getRenderer()._originalModel.animations;",
            "      const animation = animationsList.find(anim => anim.name === animationName);",
            "      if (!animation) return;",
            "",
            "      const boneTracks = animation.tracks.filter(track => track.name.includes('.position') || track.name.includes('.quaternion'));",
            "      const totalFrames = boneTracks[0].times.length || 0;",
            "",
            "      startFrame = Math.max(0, Math.min(startFrame, totalFrames - 1));",
            "      endFrame = Math.max(0, Math.min(endFrame, totalFrames - 1));",
            "",
            "      if (!threeScene.userData[gdName].boneGroups) {",
            "        threeScene.userData[gdName].boneGroups = {};",
            "      }",
            "      const boneGroup = threeScene.userData[gdName].boneGroups[boneGroupName];",
            "      if (!boneGroup) return;",
            "",
            "      let startTime = null;",
            "      let currentFrame = startFrame;",
            "      const frameDuration = (endFrame - startFrame) / (speed * 60);",
            "",
            "      function animate(currentTime) {",
            "        if (!startTime) startTime = currentTime;",
            "        const elapsedTime = currentTime - startTime;",
            "        const progress = Math.min(elapsedTime / (speed * 1000), 1);",
            "",
            "        boneTracks.forEach(track => {",
            "          const boneName = track.name.split('.')[0];",
            "          if (boneGroup.includes(boneName)) {",
            "            const bone = node.skeleton.bones.find(b => b.name === boneName);",
            "            if (bone) {",
            "              const trackType = track.name.split('.')[1];",
            "              const frame = startFrame + Math.floor(progress * (endFrame - startFrame));",
            "              if (trackType === 'position') {",
            "                const valueAtFrame = track.values.slice(frame * 3, frame * 3 + 3);",
            "                if (valueAtFrame.length === 3) {",
            "                  bone.position.set(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2]);",
            "                }",
            "              } else if (trackType === 'quaternion') {",
            "                const valueAtFrame = track.values.slice(frame * 4, frame * 4 + 4);",
            "                if (valueAtFrame.length === 4) {",
            "                  bone.quaternion.set(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2], valueAtFrame[3]);",
            "                }",
            "              }",
            "            }",
            "          }",
            "        });",
            "",
            "        node.skeleton.update();",
            "",
            "        if (progress < 1) {",
            "          requestAnimationFrame(animate);",
            "        } else {",
            "          animationData[boneGroupName] = endFrame;",
            "        }",
            "      }",
            "",
            "      if (!animationData[boneGroupName]) {",
            "        requestAnimationFrame(animate);",
            "      }",
            "    }",
            "  });",
            "}",
            "",
            "if (objects.length > 0) {",
            "  const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "  objects.forEach(obj => {",
            "    const animationName = eventsFunctionContext.getArgument(\"animationName\");",
            "    const boneGroupName = eventsFunctionContext.getArgument(\"boneGroupName\");",
            "    const startFrame = eventsFunctionContext.getArgument(\"startFrame\") || 0;",
            "    const endFrame = eventsFunctionContext.getArgument(\"endFrame\") || 0;",
            "    const speed = eventsFunctionContext.getArgument(\"speed\") || 1;",
            "    playAnimationForBoneGroup(obj, animationName, boneGroupName, startFrame, endFrame, speed);",
            "  });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        },
        {
          "description": "boneGroupName",
          "name": "boneGroupName",
          "type": "string"
        },
        {
          "description": "startFrame",
          "longDescription": "Pick any frame to start animation from",
          "name": "startFrame",
          "supplementaryInformation": "[\"startFrame\",\"endFrame\"]",
          "type": "expression"
        },
        {
          "description": "endFrame",
          "longDescription": "Pick any frame to end animation at",
          "name": "endFrame",
          "type": "expression"
        },
        {
          "description": "Bones moving speed",
          "name": "speed",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Is transition in progress",
      "fullName": "Is transition in progress",
      "functionType": "ExpressionAndCondition",
      "name": "IsMovingInProgress",
      "sentence": "Is transition in progress for: _PARAM1_ Animation name: _PARAM2_ Target frame: _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "        ",
            "        if (!threeScene.userData[gdName].transition) {",
            "            threeScene.userData[gdName].transition = {",
            "            currentAnimationId: null,",
            "            isTransitioning: false",
            "            };",
            "        }",
            "",
            "        const transitionData = threeScene.userData[gdName].transition.isTransitioning;",
            "        eventsFunctionContext.returnValue = transitionData;",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "stringWithSelector"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Animation name",
      "fullName": "Animation name",
      "functionType": "StringExpression",
      "name": "IsAnimationName",
      "sentence": "Animation name of: _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "        ",
            "        if (!threeScene.userData[gdName].animation) {",
            "            threeScene.userData[gdName].animation = {",
            "            currentFrame: null,",
            "            animationName: null ",
            "            };",
            "        }",
            "",
            "        const animationName = threeScene.userData[gdName].animation.animationName;",
            "        eventsFunctionContext.returnValue = animationName;",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "string"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Is animation name equal to",
      "fullName": "Is animation name equal to",
      "functionType": "ExpressionAndCondition",
      "name": "IsAnimationNameEqual",
      "sentence": "Is animation name of: _PARAM1_ Equals to: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "        ",
            "        if (!threeScene.userData[gdName].animation) {",
            "            threeScene.userData[gdName].animation = {",
            "            currentFrame: null,",
            "            animationName: null ",
            "            };",
            "        }",
            "",
            "        const animationName = threeScene.userData[gdName].animation.animationName;",
            "        const animationCompared = eventsFunctionContext.getArgument(\"animationName\");",
            "",
            "        if (animationName === animationCompared) {",
            "            eventsFunctionContext.returnValue = true;",
            "        } else {",
            "            eventsFunctionContext.returnValue = false;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "stringWithSelector"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Current frame",
      "fullName": "Current frame",
      "functionType": "ExpressionAndCondition",
      "name": "IsCurrentFrame",
      "sentence": "Current frame for: _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "        ",
            "        if (!threeScene.userData[gdName].transition) {",
            "            threeScene.userData[gdName].transition = {",
            "            currentAnimationId: null,",
            "            isTransitioning: false",
            "            };",
            "        }",
            "",
            "        if (!threeScene.userData[gdName].animation) {",
            "            threeScene.userData[gdName].animation = {",
            "            currentFrame: null",
            "            };",
            "        }",
            "",
            "",
            "        const frameData = threeScene.userData[gdName].animation.currentFrame;",
            "        eventsFunctionContext.returnValue = frameData;",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Max frames amount",
      "fullName": "Max frames amount",
      "functionType": "ExpressionAndCondition",
      "name": "IsMaxFrameAmount",
      "sentence": "Max frames amount for: _PARAM1_ Animation name: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const animationName = eventsFunctionContext.getArgument(\"animationName\");",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "",
            "        const animationsList = obj.getRenderer()._originalModel.animations;",
            "        const animation = animationsList.find(anim => anim.name === animationName);",
            "        if (!animation) {",
            "            return;",
            "        }",
            "",
            "        const boneTracks = animation.tracks.filter(track => track.name.includes('.position') || track.name.includes('.quaternion'));",
            "        const totalFrames = (boneTracks[0].times.length)-1 || 0;",
            "        eventsFunctionContext.returnValue = totalFrames;",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show bone names (DEBUG console)",
      "fullName": "Show bone names (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowBoneNames",
      "sentence": "Show bone names (DEBUG console) for:  _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    const bonesList = [];",
            "                    node.skeleton.bones.forEach((bone) => {",
            "                        bonesList.push(bone.name);           ",
            "                    });",
            "                    const bonesListString = bonesList.join(',');",
            "                    console.log(`Bones of ${gdName} with uuid ${node.uuid} : ${bonesListString}`);",
            "                }",
            "            });             ",
            "        }        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show bone including names (DEBUG console)",
      "fullName": "Show bone including names (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowBoneIncludeChars",
      "sentence": "Show bone including names (DEBUG console) for:  _PARAM1_ Names: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const boneNamesToSearch = eventsFunctionContext.getArgument(\"boneNamesToSearch\").split(',').map(name => name.trim().toLowerCase());",
            "",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    const bonesList = [];",
            "                    node.skeleton.bones.forEach((bone) => {",
            "                        const boneNameLower = bone.name.toLowerCase();",
            "                        if (boneNamesToSearch.some(searchName => boneNameLower.includes(searchName))) {",
            "                            bonesList.push(bone.name);",
            "                        }",
            "                    });",
            "                    const bonesListString = bonesList.join(',');",
            "                    console.log(`Bones of ${gdName} with uuid ${node.uuid} : ${bonesListString}`);",
            "                }",
            "            });             ",
            "        }        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Array of names",
          "longDescription": "Example: if a mesh has bones  \"LegBoneUp\",  \"LegBoneLow\" and you write \"leg\" here all bones with \"Leg\" or \"leg\" will be shown",
          "name": "boneNamesToSearch",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show all bone groups (DEBUG console)",
      "fullName": "Show all bone groups (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowAllBoneGroups",
      "sentence": "Show all bone groups (DEBUG console) for:  _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    if (!scene.userData || !scene.userData[gdName] || !scene.userData[gdName].boneGroups ) {",
            "                        return;",
            "                    }",
            "",
            "                    console.log(`All bone groups of ${JSON.stringify(gdName)} :  ${JSON.stringify(scene.userData[gdName].boneGroups)}`)",
            "                }",
            "            });             ",
            "        }",
            "        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show animations list (DEBUG console)",
      "fullName": "Show animations list (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowAnimationsList",
      "sentence": "Show animations list (DEBUG console) for:  _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh) {",
            "                    const animations = obj._animations;",
            "                    if (animations.length === 0) {",
            "                        return;",
            "                    }",
            "",
            "                    console.log(`Animations of ${JSON.stringify(gdName)} :  ${JSON.stringify(animations)}`)",
            "                }",
            "            });             ",
            "        }",
            "        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show a bone group's bones (DEBUG console)",
      "fullName": "Show a bone group's bones (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowBoneGroupBones",
      "sentence": "Show a bone group's bones (DEBUG console) for:  _PARAM1_ Group name: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const groupName = eventsFunctionContext.getArgument(\"groupName\");",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    if (!scene.userData || !scene.userData[gdName] || !scene.userData[gdName].boneGroups ) {",
            "                        return;",
            "                    }",
            "                    const boneGroup = scene.userData[gdName].boneGroups[groupName];",
            "                    const bonesListString = boneGroup.join(',');",
            "                    if (bonesListString.length > 0) {",
            "                        console.log(`Bone group bones of ${JSON.stringify(gdName)} for group name ${JSON.stringify(groupName)} :  ${JSON.stringify(bonesListString)}`)",
            "                    }",
            "                }",
            "            });             ",
            "        }        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Bone group name",
          "name": "groupName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Create bone group",
      "fullName": "Create bone group",
      "functionType": "Action",
      "name": "CreateBoneGroup",
      "sentence": "Create bone group for:  _PARAM1_ Bone names: _PARAM2_ Bone group name: _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const boneNames = eventsFunctionContext.getArgument(\"boneNames\").replace(/\\s+/g, '').split(',');",
            "    const boneGroupName = eventsFunctionContext.getArgument(\"groupName\");",
            "",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const bonesList = [];",
            "",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh) {",
            "                    node.skeleton.bones.forEach((bone) => {",
            "                        if (boneNames.includes(bone.name) && !bonesList.includes(bone.name)) {",
            "                            bonesList.push(bone.name);",
            "                        }",
            "                    });",
            "                }",
            "            });",
            "        }",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "        if (!threeScene.userData[gdName].boneGroups) {",
            "            threeScene.userData[gdName].boneGroups = {};",
            "        }",
            "        if (!threeScene.userData[gdName].boneGroups[boneGroupName]) {",
            "            threeScene.userData[gdName].boneGroups[boneGroupName] = [];",
            "        }",
            "",
            "        bonesList.forEach(boneName => {",
            "            if (!threeScene.userData[gdName].boneGroups[boneGroupName].includes(boneName)) {",
            "                threeScene.userData[gdName].boneGroups[boneGroupName].push(boneName);",
            "            }",
            "        });",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Bone names list ",
          "longDescription": "\"bone1,bone2,bone3...\"",
          "name": "boneNames",
          "type": "string"
        },
        {
          "description": "Group name",
          "name": "groupName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Test",
      "fullName": "Test",
      "functionType": "Action",
      "name": "Test",
      "sentence": "Test",
      "events": [
        {
          "colorB": 228,
          "colorG": 176,
          "colorR": 74,
          "creationTime": 0,
          "name": "Animation mixer",
          "source": "",
          "type": "BuiltinCommonInstructions::Group",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (objects.length > 0) {",
                "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "    objects.forEach(obj => {",
                "        const rendererObject = obj.get3DRendererObject();",
                "        const indexArgument = 0;",
                "        const gdName = obj.getName() + obj.getUniqueId();",
                "        const animationName = \"twerk\";  ",
                "        const timeScale = 1 ",
                "",
                "        rendererObject.traverse((node) => {",
                "            if (node.isSkinnedMesh) {",
                "                const animationMixer = obj.getRenderer()._animationMixer;",
                "                const animationsList = obj.getRenderer()._originalModel.animations;",
                "",
                "                const animation = animationsList.find(anim => anim.name === animationName);",
                "                if (!animation) {",
                "                    console.error(`Animation '${animationName}' not found.`);",
                "                    return;",
                "                }",
                "",
                "                const boneTracks = animation.tracks.filter(track => track.name.includes('.position') || track.name.includes('.quaternion'));",
                "",
                "                let currentFrame = 0;",
                "                const totalFrames = boneTracks[0].times.length || 0; ",
                "                let accumulatedTime = 0;",
                "                console.log(JSON.stringify(totalFrames))",
                "                ",
                "",
                "                const animateBones = (timestamp) => {",
                "                    if (currentFrame >= totalFrames) return;  ",
                "",
                "                    const deltaTime = timestamp - (animateBones.lastTimestamp || 0);",
                "                    animateBones.lastTimestamp = timestamp;",
                "console.log(JSON.stringify(currentFrame))",
                "                    accumulatedTime += deltaTime * timeScale;",
                "",
                "                    const frameDuration = 1000 / 60;",
                "",
                "                    while (accumulatedTime >= frameDuration) {",
                "                        boneTracks.forEach(track => {",
                "                            const boneName = track.name.split('.')[0];",
                "                            const bone = node.skeleton.bones.find(b => b.name === boneName);",
                "                            ",
                "                            if (bone) {",
                "                                const trackType = track.name.split('.')[1];  ",
                "                                ",
                "                                if (trackType === 'position') {",
                "                                    const valueAtFrame = track.values.slice(currentFrame * 3, currentFrame * 3 + 3);",
                "",
                "                                    if (valueAtFrame.length === 3) {",
                "                                        bone.position.set(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2]);",
                "                                    }",
                "                                } else if (trackType === 'quaternion') {",
                "                                    const valueAtFrame = track.values.slice(currentFrame * 4, currentFrame * 4 + 4);",
                "",
                "                                    if (valueAtFrame.length === 4) {",
                "                                        bone.quaternion.set(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2], valueAtFrame[3]);",
                "                                    }",
                "                                }",
                "                            } ",
                "                        });",
                "",
                "                        node.skeleton.update(); ",
                "                        currentFrame++;",
                "                        accumulatedTime -= frameDuration;",
                "                        if (currentFrame >= totalFrames) break;",
                "                    }",
                "",
                "                    requestAnimationFrame(animateBones);  ",
                "                };",
                "",
                "                animateBones.lastTimestamp = performance.now();",
                "                requestAnimationFrame(animateBones); ",
                "            }",
                "        });",
                "    });",
                "}"
              ],
              "parameterObjects": "id",
              "useStrict": true,
              "eventsSheetExpanded": true
            },
            {
              "disabled": true,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (objects.length > 0) {",
                "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "    objects.forEach(obj => {",
                "        const rendererObject = obj.get3DRendererObject();",
                "        const indexArgument = 0;",
                "        const gdName = obj.getName() + obj.getUniqueId();",
                "        const animationName = \"dance\";  ",
                "",
                "        rendererObject.traverse((node) => {",
                "            if (node.isSkinnedMesh) {",
                "                const animationMixer = obj.getRenderer()._animationMixer;",
                "                const animationsList = obj.getRenderer()._originalModel.animations;",
                "",
                "                const animation = animationsList.find(anim => anim.name === animationName);",
                "                if (!animation) {",
                "                    console.error(`Animation '${animationName}' not found.`);",
                "                    return;",
                "                }",
                "",
                "                const boneTracks = animation.tracks.filter(track => track.name.includes('.position') || track.name.includes('.quaternion'));",
                "",
                "                let currentFrame = 0;",
                "                const totalFrames = boneTracks[0].times.length || 0; ",
                "",
                "                const animateBones = () => {",
                "                    if (currentFrame >= totalFrames) return;  ",
                "",
                "                    boneTracks.forEach(track => {",
                "                        const boneName = track.name.split('.')[0];",
                "                        const bone = node.skeleton.bones.find(b => b.name === boneName);",
                "                        ",
                "                        if (bone) {",
                "                            const trackType = track.name.split('.')[1];  ",
                "                            ",
                "                            if (trackType === 'position') {",
                "                                const valueAtFrame = track.values.slice(currentFrame * 3, currentFrame * 3 + 3);",
                "",
                "                                if (valueAtFrame.length === 3) {",
                "                                    bone.position.set(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2]);",
                "                                }",
                "                            } else if (trackType === 'quaternion') {",
                "                                const valueAtFrame = track.values.slice(currentFrame * 4, currentFrame * 4 + 4);",
                "",
                "                                if (valueAtFrame.length === 4) {",
                "                                    bone.quaternion.set(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2], valueAtFrame[3]);",
                "                                }",
                "                            }",
                "                        } ",
                "                    });",
                "",
                "                    node.skeleton.update(); ",
                "                    currentFrame++;",
                "                    requestAnimationFrame(animateBones);  ",
                "                };",
                "",
                "                animateBones(); ",
                "            }",
                "        });",
                "    });",
                "}",
                ""
              ],
              "parameterObjects": "id",
              "useStrict": true,
              "eventsSheetExpanded": false
            },
            {
              "disabled": true,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (objects.length > 0) {",
                "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "    objects.forEach(obj => {",
                "        const rendererObject = obj.get3DRendererObject();",
                "        const indexArgument = 0;",
                "        const gdName = obj.getName() + obj.getUniqueId();",
                "        const pickedName = scene.userData[gdName].skinnedMesh[indexArgument];",
                "        const animationName = \"dance\";  // The animation you want to apply",
                "",
                "        rendererObject.traverse((node) => {",
                "            if (node.isSkinnedMesh && node.uuid === pickedName) {",
                "                const animationMixer = obj.getRenderer()._animationMixer;",
                "                const animationsList = obj.getRenderer()._originalModel.animations;",
                "",
                "                // Find the animation by name",
                "                const animation = animationsList.find(anim => anim.name === animationName);",
                "                if (!animation) {",
                "                    console.error(`Animation '${animationName}' not found.`);",
                "                    return;",
                "                }",
                "",
                "                // Get the tracks related to the bones",
                "                const boneTracks = animation.tracks.filter(track => track.name.includes('.position') || track.name.includes('.quaternion'));",
                "",
                "                // Assume we want to animate the bones gradually, frame by frame",
                "                let currentFrame = 0;",
                "                const totalFrames = boneTracks[0]?.times.length || 0; // Assuming all tracks have the same number of frames",
                "",
                "                const animateBones = () => {",
                "                    if (currentFrame >= totalFrames) return;  // Stop when reaching the last frame",
                "",
                "                    boneTracks.forEach(track => {",
                "                        // Extract the bone name from the track's name (e.g., 'Bone.position')",
                "                        const boneName = track.name.split('.')[0];",
                "                        const bone = node.skeleton.bones.find(b => b.name === boneName);",
                "                        ",
                "                        if (bone) {",
                "                            const trackType = track.name.split('.')[1];  // 'position' or 'quaternion'",
                "                            const valueAtFrame = track.values.slice(currentFrame * 3, currentFrame * 3 + 3);",
                "",
                "                            console.log(`Applying ${trackType} for bone '${boneName}' at frame ${currentFrame}:`, valueAtFrame);",
                "",
                "                            // Ensure the values are valid before applying them",
                "                            if (trackType === 'position' && valueAtFrame.length === 3) {",
                "                                // Apply position keyframe",
                "                                bone.position.set(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2]);",
                "                            } else if (trackType === 'quaternion' && valueAtFrame.length === 4) {",
                "                                // Apply quaternion keyframe",
                "                                bone.quaternion.set(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2], valueAtFrame[3]);",
                "                            }",
                "                        } else {",
                "                            console.warn(`Bone '${boneName}' not found in skeleton.`);",
                "                        }",
                "                    });",
                "",
                "                    node.skeleton.update();  // Ensure skeleton is updated after changes",
                "                    currentFrame++;",
                "                    requestAnimationFrame(animateBones);  // Continue to the next frame",
                "                };",
                "",
                "                animateBones();  // Start the gradual animation",
                "            }",
                "        });",
                "    });",
                "}",
                ""
              ],
              "parameterObjects": "id",
              "useStrict": true,
              "eventsSheetExpanded": false
            },
            {
              "disabled": true,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (objects.length > 0) {",
                "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "    objects.forEach(obj => {",
                "        const rendererObject = obj.get3DRendererObject();",
                "        const indexArgument = 0;",
                "        const gdName = obj.getName() + obj.getUniqueId();",
                "        const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "        const pickedName = scene.userData[gdName].skinnedMesh[indexArgument];",
                "        const animationName = \"dance\";",
                "",
                "        rendererObject.traverse((node) => {",
                "            if (node.isSkinnedMesh && node.uuid === pickedName) {",
                "                const animationMixer = obj.getRenderer()._animationMixer;",
                "                const animationsList = obj.getRenderer()._originalModel.animations;",
                "",
                "                // Calculate the number of frames for each animation",
                "                animationsList.forEach(animation => {",
                "                    const frameCount = animation.tracks.reduce((totalFrames, track) => {",
                "                        return totalFrames + track.times.length;",
                "                    }, 0);",
                "                    console.log(`Animation '${animation.name}' has ${frameCount} frames.`);",
                "                });",
                "            }",
                "        });",
                "    });",
                "}"
              ],
              "parameterObjects": "id",
              "useStrict": true,
              "eventsSheetExpanded": false
            },
            {
              "disabled": true,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (objects.length > 0) {",
                "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "    objects.forEach(obj => {",
                "        const rendererObject = obj.get3DRendererObject();",
                "        const indexArgument = 0;",
                "        const gdName = obj.getName() + obj.getUniqueId();",
                "        const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "        const pickedName = scene.userData[gdName].skinnedMesh[indexArgument];",
                "",
                "        rendererObject.traverse((node) => {",
                "            if (node.isSkinnedMesh && node.uuid === pickedName) {",
                "                const animationMixer = obj.getRenderer()._animationMixer;",
                "                const animationsList = obj.getRenderer()._originalModel.animations;",
                "",
                "                // Log all parameter names of each animation",
                "                animationsList.forEach(animation => {",
                "                    const parameterNames = Object.keys(animation);",
                "                    console.log(`Parameter Names for Animation '${animation.name}':`, parameterNames);",
                "                });",
                "            }",
                "        });",
                "    });",
                "}"
              ],
              "parameterObjects": "id",
              "useStrict": true,
              "eventsSheetExpanded": false
            },
            {
              "disabled": true,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (objects.length > 0) {",
                "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "    objects.forEach(obj => {",
                "        const rendererObject = obj.get3DRendererObject();",
                "        const indexArgument = 0;",
                "        const gdName = obj.getName() + obj.getUniqueId();",
                "        const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "        const pickedName = scene.userData[gdName].skinnedMesh[indexArgument];",
                "",
                "        rendererObject.traverse((node) => {",
                "            if (node.isSkinnedMesh && node.uuid === pickedName) {",
                "                const animationMixer = obj.getRenderer()._animationMixer;",
                "                const animationsList = obj.getRenderer()._originalModel.animations;",
                "",
                "                animationsList.forEach(animation => {",
                "                    console.log(`Animation Name: ${animation.name}, Duration: ${animation.duration}`);",
                "                });",
                "            }",
                "        });",
                "    });",
                "}"
              ],
              "parameterObjects": "id",
              "useStrict": true,
              "eventsSheetExpanded": false
            },
            {
              "disabled": true,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (objects.length > 0) {",
                "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "    objects.forEach(obj => {",
                "        const rendererObject = obj.get3DRendererObject();",
                "        const indexArgument = 0;",
                "        const gdName = obj.getName() + obj.getUniqueId();",
                "        const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
                "        const pickedName = scene.userData[gdName].skinnedMesh[indexArgument];",
                "",
                "        rendererObject.traverse((node) => {",
                "            if (node.isSkinnedMesh && node.uuid === pickedName) {",
                "                // Access the AnimationMixer and AnimationAction",
                "                const animationMixer = obj.getRenderer()._animationMixer;",
                "                const animationName = \"dance\"; ",
                "                const origAnimations = obj.getRenderer()._originalModel.animations;",
                "",
                "                console.log(JSON.stringify(origAnimations))",
                "",
                "                // Stop all current actions",
                "                animationMixer.stopAllAction();",
                "",
                "                // Find the AnimationClip by name",
                "                const clip = THREE.AnimationClip.findByName(",
                "                    obj.getRenderer()._originalModel.animations,",
                "                    animationName",
                "                );",
                "",
                "                if (!clip) {",
                "                    console.error(",
                "                        `The GLB file: ${obj.getRenderer()._model3DRuntimeObject._modelResourceName} doesn't have any animation named: ${animationName}`",
                "                    );",
                "                    return;",
                "                }",
                "",
                "                // Create an AnimationAction",
                "                const action = animationMixer.clipAction(clip);",
                "                action.setLoop(THREE.LoopRepeat, Number.POSITIVE_INFINITY);",
                "                action.clampWhenFinished = true;",
                "                action.play();",
                "",
                "                // Make sure the first frame is displayed",
                "                animationMixer.update(0);",
                "",
                "                console.log(`Playing animation: ${animationName}`);",
                "            }",
                "        });",
                "    });",
                "}"
              ],
              "parameterObjects": "id",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": []
        },
        {
          "disabled": true,
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const indexArgument = 0;",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "        const pickedName = scene.userData[gdName].skinnedMesh[indexArgument];",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.uuid === pickedName) {",
            "                    console.log(JSON.stringify(obj.getAnimationName()))",
            "                    obj.getRenderer().playAnimation(\"dance\", true);",
            "                }",
            "            });",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        },
        {
          "disabled": true,
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const indexArgument = 0;",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "        const animationName = \"dance\";",
            "        const pickedName = scene.userData[gdName].skinnedMesh[indexArgument];",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.uuid === pickedName) {",
            "                    function DownloadTextContent(filename, mimeType,content) {",
            "                        var link = document.createElement('a')",
            "                        var blob = new Blob([content], {type: mimeType})",
            "                        var url = URL.createObjectURL(blob);",
            "",
            "                        link.setAttribute('href', url);",
            "                        link.setAttribute('download', filename);",
            "                        link.click();",
            "                        link.remove();",
            "                    }",
            "",
            "                    const FileName = \"aa\";",
            "                    const TextContent = JSON.stringify(node.userData);",
            "",
            "                    DownloadTextContent(FileName, \"text/plain\", TextContent);                    ",
            "                }",
            "            });",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        },
        {
          "disabled": true,
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh) {",
            "                   const dataAnim = node.userData;",
            "                   console.log(JSON.stringify(dataAnim))",
            "                }",
            "            });",
            "        }",
            "    });",
            "} ",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        },
        {
          "disabled": true,
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "const infa = scene.userData",
            "",
            "",
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj, index) => {",
            "        const skinnedMeshList = [];",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    const nodeData = node.userData.twerk_frameAmount;",
            "                    console.log(`Name : ${JSON.stringify(node.name)}+${JSON.stringify(node.type)} +++ twerk: ${JSON.stringify(nodeData)}`)",
            "                    const nodeData2 = node.userData.dance_frameAmount;",
            "                    console.log(`Name : ${JSON.stringify(node.name)}+${JSON.stringify(node.type)} +++ dance: ${JSON.stringify(nodeData2)}`)",
            "                    const nodeData3 = node.userData.begging_frameAmount;",
            "                    console.log(`Name : ${JSON.stringify(node.name)}+${JSON.stringify(node.type)} +++ begging: ${JSON.stringify(nodeData3)}`)",
            "                    const nodeData4 = node.userData.taunt_frameAmount;",
            "                    console.log(`Name : ${JSON.stringify(node.name)}+${JSON.stringify(node.type)} +++ taunt: ${JSON.stringify(nodeData4)}`)",
            "                }",
            "            });",
            "        }",
            "    });",
            "};",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        },
        {
          "disabled": true,
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const deltaTime = runtimeScene.getTimeManager().getElapsedTime() / 1000.0;",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    console.log(`Data : ${JSON.stringify(node.userData[\"taunt\" + \"_frame_\" + 0])}`);  ",
            "                          ",
            "                }",
            "            });",
            "        }",
            "    });",
            "}",
            "",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        },
        {
          "disabled": true,
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const deltaTime = runtimeScene.getTimeManager().getElapsedTime() / 1000.0;",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    ",
            "                    //obj.setAnimationElapsedTime(0);",
            "",
            "                    //const animations = obj._animations;",
            "                    //obj.setAnimationName(animationName);",
            "                    //obj.setAnimationElapsedTime(obj.getAnimationDuration());",
            "                    //obj.pauseAnimation();   ",
            "                    const duration =  obj.getAnimationDuration();",
            "                    const totalFrames = Math.round(duration/deltaTime);",
            "                    const oneFrame = duration/totalFrames;",
            "                    obj.setAnimationElapsedTime();",
            "                    console.log(`duration: ${JSON.stringify(duration)}`); ",
            "                    console.log(`frames round: ${JSON.stringify(numberOfFramesRound)}`);",
            "                    console.log(`oneFrame: ${JSON.stringify(oneFrame)}`);          ",
            "                }",
            "            });",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        },
        {
          "disabled": true,
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const deltaTime = runtimeScene.getTimeManager().getElapsedTime() / 1000.0;",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    // Access the AnimationMixer",
            "                    const animationMixer = new THREE.AnimationMixer(node);",
            "                    console.log(`AnimationMixer created for object ${gdName}.`);",
            "",
            "                    const animations = obj._animations;",
            "                    console.log(`AnimationMixer update rate for object ${gdName}: ${animationMixer.timeScale}`);",
            "                    console.log(`Anima ${gdName}: ${JSON.stringify(animations)}`);",
            "",
            "                    animations.forEach(clip => {",
            "                        console.log(`clip: ${JSON.stringify(clip.name)}`);",
            "                        console.log(`clip source: ${JSON.stringify(clip.source)}`);",
            "                        const duration = obj.getRenderer().getAnimationDuration(clip.source);",
            "                        const numberOfFrames = Math.round(duration/deltaTime);",
            "                        console.log(`frames: ${JSON.stringify(numberOfFrames)}`);",
            "                        console.log(`duration: ${JSON.stringify(duration)}`);",
            "                    });",
            "",
            "                    ",
            "                }",
            "            });",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        },
        {
          "disabled": true,
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "// Access the Three.js scene",
            "const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "",
            "// Function to log the number of frames in the animation at a specific index",
            "function logAnimationFrames(object, animationIndex) {",
            "    const animations = object._animations; // Access the animations directly",
            "    if (animations && animations.length > animationIndex) {",
            "        const animation = animations[animationIndex];",
            "        const animationName = animation.source;",
            "        ",
            "        // Assuming a typical frame rate of 24 frames per second if not specified",
            "        const frameRate = 24;",
            "        const duration = object.getRenderer().getAnimationDuration(animationName);",
            "        const numberOfFrames = Math.round(duration * frameRate);",
            "        ",
            "        console.log(`Animation at index ${animationIndex} (\"${animationName}\") has ${numberOfFrames} frames.`);",
            "    } else {",
            "        console.log(`Animation at index ${animationIndex} not found on object \"${object.getName()}\".`);",
            "    }",
            "}",
            "",
            "// Find the object by name and log the number of frames in the animation at index 1",
            "const objectName = \"zombie1\"; // Replace with the name of your object",
            "const instanceContainer = runtimeScene;",
            "const object = instanceContainer.getObjects(objectName)[0];",
            "",
            "if (object) {",
            "    // Example: Log the number of frames in the animation at index 1",
            "    const animationIndex = 0; // Replace with the index of the animation you want to check",
            "    logAnimationFrames(object, animationIndex);",
            "} else {",
            "    console.log(`Object with name \"${objectName}\" not found.`);",
            "}"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        },
        {
          "disabled": true,
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "// Access the Three.js scene",
            "const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "",
            "// Function to log all animations of the object by name",
            "function logAnimations(object) {",
            "    const animations = object._animations; // Access the animations directly",
            "    if (animations && animations.length > 0) {",
            "        let animationsInfo = animations.map(animation => ({",
            "            name: animation.name,",
            "            source: animation.source,",
            "            loop: animation.loop",
            "        }));",
            "        console.log(JSON.stringify(animationsInfo, null, 2));",
            "    } else {",
            "        console.log(`Object \"${object.getName()}\" has no animations.`);",
            "    }",
            "}",
            "",
            "// Function to play a specific animation by name",
            "function playAnimation(object, animationName) {",
            "    object.setAnimationName(animationName);",
            "    console.log(`Playing animation \"${animationName}\" on object \"${object.getName()}\".`);",
            "}",
            "",
            "// Find the object by name and log its animations",
            "const objectName = \"zombie1\"; // Replace with the name of your object",
            "const instanceContainer = runtimeScene;",
            "const object = instanceContainer.getObjects(objectName)[0];",
            "",
            "if (object) {",
            "    logAnimations(object);",
            "",
            "    // Example: Play a specific animation by name",
            "    const animationName = \"walking\"; // Replace with the name of the animation you want to play",
            "    playAnimation(object, animationName);",
            "} else {",
            "    console.log(`Object with name \"${objectName}\" not found.`);",
            "}"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}