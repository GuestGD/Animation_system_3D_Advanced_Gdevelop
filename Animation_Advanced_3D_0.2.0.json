{
  "author": "",
  "category": "General",
  "extensionNamespace": "",
  "fullName": "Animation system 3d Advanced",
  "helpPath": "https://github.com/GuestGD/Animation_system_3D_Advanced_Gdevelop",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXZpZGVvLW1pbnVzLW91dGxpbmUiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTUgOFYxNkg1VjhIMTVNMTYgNkg0QzMuNDUgNiAzIDYuNDUgMyA3VjE3QzMgMTcuNTUgMy40NSAxOCA0IDE4SDE2QzE2LjU1IDE4IDE3IDE3LjU1IDE3IDE3VjEzLjVMMjEgMTcuNVY2LjVMMTcgMTAuNVY3QzE3IDYuNDUgMTYuNTUgNiAxNiA2TTEzIDEzSDdWMTFIMTNWMTNaIiAvPjwvc3ZnPg==",
  "name": "AnimationTransition3D",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/dc34dfac0916a53f58ba6fc06801a4ea79e144b2cc1c200fc07ada8a971ce6b7_video-minus-outline.svg",
  "shortDescription": "Animation system 3d Advanced",
  "version": "0.2",
  "description": [
    "- Make a smooth transition between any mesh animations",
    "- Move between any frames of different animations",
    "- Create bone groups to play several animations simultaneously",
    "- Move any bone",
    "- Find bone names"
  ],
  "tags": [
    "animation 3d transition advanced bones skeleton"
  ],
  "authorIds": [
    "W0yoMQqOeiULIwY1i1Qd8tprOyD2"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "description": "Play animation by name",
      "fullName": "Play animation by name",
      "functionType": "Action",
      "name": "Play",
      "private": true,
      "sentence": "Play animation by name for: _PARAM1_ Animation name: _PARAM2_ Speed: _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length >0) {",
            "    const objectName = objects[0].getName();",
            "    const animationName = eventsFunctionContext.getArgument(\"animationName\"); ",
            "    const speedScale = eventsFunctionContext.getArgument(\"playSpeed\"); ",
            "",
            "    const object = runtimeScene.getObjects(objectName)[0];",
            "",
            "    if (object && object instanceof gdjs.Model3DRuntimeObject) {",
            "        const currentSpeed = object.getAnimationSpeedScale();",
            "",
            "        const renderer = object.getRenderer();",
            "        const isEnded = renderer.hasAnimationEnded();",
            "        if (renderer.hasAnimationEnded()) {",
            "            if (currentSpeed !== speedScale) {",
            "                object.setAnimationSpeedScale(speedScale);",
            "            }",
            "            object.setAnimationElapsedTime(0)",
            "            renderer.playAnimation(animationName);",
            "        }",
            "    }",
            "",
            "};",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        },
        {
          "description": "Speed of animation",
          "name": "playSpeed",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Animation transition",
      "fullName": "Animation transition",
      "functionType": "Action",
      "name": "PlayTransition",
      "sentence": "Animation transition of: _PARAM1_ To animation name: _PARAM2_ Target frame: _PARAM3_ Custom frame: _PARAM4_  Time: _PARAM5_  ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function transitionToPose(obj, transitionDuration) {",
            "  const rendererObject = obj.get3DRendererObject();",
            "  const gdName = obj.getName() + obj.getUniqueId();",
            "  const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "  const animationName = eventsFunctionContext.getArgument(\"animationName\");",
            "  const frame = eventsFunctionContext.getArgument(\"pickFrame\") || \"startFrame\";",
            "  const frameCustom = eventsFunctionContext.getArgument(\"pickFrameCustom\") || 0;",
            "",
            "  if (!threeScene.userData[gdName]) {",
            "    threeScene.userData[gdName] = {};",
            "  }",
            "  if (!threeScene.userData[gdName].transition) {",
            "    threeScene.userData[gdName].transition = {",
            "      currentAnimationId: null,",
            "      isTransitioning: false",
            "    };",
            "  }",
            "  if (!threeScene.userData[gdName].animation) {",
            "    threeScene.userData[gdName].animation = {",
            "      currentFrame: null,",
            "      animationName: null ",
            "    };",
            "  }",
            "  const transitionData = threeScene.userData[gdName].transition;",
            "  const animationData = threeScene.userData[gdName].animation;",
            "",
            "  animationData.animationName = animationName;",
            "",
            "  function stopTransition() {",
            "    if (transitionData.currentAnimationId !== null) {",
            "      cancelAnimationFrame(transitionData.currentAnimationId);",
            "      transitionData.currentAnimationId = null;",
            "    }",
            "    transitionData.isTransitioning = false;",
            "  }",
            "",
            "  if (transitionData.isTransitioning) {",
            "    stopTransition();",
            "    return;",
            "  }",
            "",
            "  rendererObject.traverse((node) => {",
            "    if (node.isSkinnedMesh) {",
            "      const animationsList = obj.getRenderer()._originalModel.animations;",
            "      const animation = animationsList.find(anim => anim.name === animationName);",
            "      if (!animation) {",
            "        return;",
            "      }",
            "",
            "      const boneTracks = animation.tracks.filter(track => track.name.includes('.position') || track.name.includes('.quaternion'));",
            "      const totalFrames = boneTracks[0].times.length || 0;",
            "",
            "      let desiredFrame;",
            "      switch (frame) {",
            "        case \"startFrame\":",
            "          desiredFrame = 0;",
            "          break;",
            "        case \"endFrame\":",
            "          desiredFrame = totalFrames - 1;",
            "          break;",
            "        case \"customFrame\":",
            "          desiredFrame = Math.max(0, Math.min(frameCustom, totalFrames - 1));",
            "          break;",
            "        default:",
            "          desiredFrame = 0;",
            "          break;",
            "      }",
            "",
            "      if (desiredFrame === animationData.currentFrame || (animationData.currentFrame === totalFrames - 1 && desiredFrame >= totalFrames - 1)) {",
            "        return;",
            "      }",
            "",
            "      const initialBoneStates = new Map();",
            "      boneTracks.forEach(track => {",
            "        const boneName = track.name.split('.')[0];",
            "        const bone = node.skeleton.bones.find(b => b.name === boneName);",
            "        if (bone) {",
            "          initialBoneStates.set(boneName, {",
            "            position: bone.position.clone(),",
            "            quaternion: bone.quaternion.clone()",
            "          });",
            "        }",
            "      });",
            "",
            "      const targetBoneStates = new Map();",
            "      boneTracks.forEach(track => {",
            "        const boneName = track.name.split('.')[0];",
            "        const trackType = track.name.split('.')[1];",
            "        if (trackType === 'position') {",
            "          const valueAtFrame = track.values.slice(desiredFrame * 3, desiredFrame * 3 + 3);",
            "          if (valueAtFrame.length === 3) {",
            "            targetBoneStates.set(boneName, {",
            "              ...targetBoneStates.get(boneName),",
            "              position: new THREE.Vector3(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2])",
            "            });",
            "          }",
            "        } else if (trackType === 'quaternion') {",
            "          const valueAtFrame = track.values.slice(desiredFrame * 4, desiredFrame * 4 + 4);",
            "          if (valueAtFrame.length === 4) {",
            "            targetBoneStates.set(boneName, {",
            "              ...targetBoneStates.get(boneName),",
            "              quaternion: new THREE.Quaternion(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2], valueAtFrame[3])",
            "            });",
            "          }",
            "        }",
            "      });",
            "",
            "      let startTime = null;",
            "      transitionData.isTransitioning = true;",
            "",
            "      function animate(currentTime) {",
            "        if (!transitionData.isTransitioning) {",
            "          return;",
            "        }",
            "",
            "        if (!startTime) startTime = currentTime;",
            "        const elapsedTime = currentTime - startTime;",
            "        const progress = Math.min(elapsedTime / transitionDuration, 1);",
            "",
            "        boneTracks.forEach(track => {",
            "          const boneName = track.name.split('.')[0];",
            "          const bone = node.skeleton.bones.find(b => b.name === boneName);",
            "          if (bone) {",
            "            const initialState = initialBoneStates.get(boneName);",
            "            const targetState = targetBoneStates.get(boneName);",
            "",
            "            if (initialState && targetState) {",
            "              if (initialState.position && targetState.position) {",
            "                bone.position.lerpVectors(initialState.position, targetState.position, progress);",
            "              }",
            "              if (initialState.quaternion && targetState.quaternion) {",
            "                bone.quaternion.slerpQuaternions(initialState.quaternion, targetState.quaternion, progress);",
            "              }",
            "            }",
            "          }",
            "        });",
            "",
            "        node.skeleton.update();",
            "",
            "        if (progress < 1) {",
            "          transitionData.currentAnimationId = requestAnimationFrame(animate);",
            "        } else {",
            "          animationData.currentFrame = desiredFrame;",
            "          stopTransition();",
            "        }",
            "      }",
            "",
            "      transitionData.currentAnimationId = requestAnimationFrame(animate);",
            "    }",
            "  });",
            "}",
            "",
            "if (objects.length > 0) {",
            "  const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "  objects.forEach(obj => {",
            "    obj.pauseAnimation();",
            "    const speed = eventsFunctionContext.getArgument(\"speed\") * 1000 || 1000;",
            "    transitionToPose(obj, speed);",
            "  });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        },
        {
          "description": "Target frame",
          "longDescription": "Pick start or end frame of the animation. The current animation will be paused and changed to selected one. After the transition is finished the new animation is paused.",
          "name": "pickFrame",
          "supplementaryInformation": "[\"startFrame\",\"endFrame\",\"customFrame\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Pick custom frame",
          "name": "pickFrameCustom",
          "type": "expression"
        },
        {
          "description": "Time in seconds required to reach a target frame",
          "longDescription": "Amount of seconds required to reach a target frame (higher value = slower transition)",
          "name": "speed",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Play bone group animation",
      "fullName": "Play bone group animation",
      "functionType": "Action",
      "name": "PlayBoneGroupAnimation",
      "sentence": "Play bone group animation of: _PARAM1_ Animation: _PARAM2_ Bone group: _PARAM3_ Start frame: _PARAM4_  End frame: _PARAM5_  Speed: _PARAM6_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function playAnimationForBoneGroup(obj, animationName, boneGroupName, startFrame, endFrame, speed) {",
            "  const rendererObject = obj.get3DRendererObject();",
            "  const gdName = obj.getName() + obj.getUniqueId();",
            "  const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "",
            "  if (!threeScene.userData[gdName]) {",
            "    threeScene.userData[gdName] = {};",
            "  }",
            "  if (!threeScene.userData[gdName].animation) {",
            "    threeScene.userData[gdName].animation = {};",
            "  }",
            "  const animationData = threeScene.userData[gdName].animation;",
            "",
            "  rendererObject.traverse((node) => {",
            "    if (node.isSkinnedMesh) {",
            "      const animationsList = obj.getRenderer()._originalModel.animations;",
            "      const animation = animationsList.find(anim => anim.name === animationName);",
            "      if (!animation) return;",
            "",
            "      const boneTracks = animation.tracks.filter(track => track.name.includes('.position') || track.name.includes('.quaternion'));",
            "      const totalFrames = boneTracks[0].times.length || 0;",
            "",
            "      startFrame = Math.max(0, Math.min(startFrame, totalFrames - 1));",
            "      endFrame = Math.max(0, Math.min(endFrame, totalFrames - 1));",
            "",
            "      if (!threeScene.userData[gdName].boneGroups) {",
            "        threeScene.userData[gdName].boneGroups = {};",
            "      }",
            "      const boneGroup = threeScene.userData[gdName].boneGroups[boneGroupName];",
            "      if (!boneGroup) return;",
            "",
            "      let startTime = null;",
            "      let currentFrame = startFrame;",
            "      const frameDuration = (endFrame - startFrame) / (speed * 60);",
            "",
            "      function animate(currentTime) {",
            "        if (!startTime) startTime = currentTime;",
            "        const elapsedTime = currentTime - startTime;",
            "        const progress = Math.min(elapsedTime / (speed * 1000), 1);",
            "",
            "        boneTracks.forEach(track => {",
            "          const boneName = track.name.split('.')[0];",
            "          if (boneGroup.includes(boneName)) {",
            "            const bone = node.skeleton.bones.find(b => b.name === boneName);",
            "            if (bone) {",
            "              const trackType = track.name.split('.')[1];",
            "              const frame = startFrame + Math.floor(progress * (endFrame - startFrame));",
            "              if (trackType === 'position') {",
            "                const valueAtFrame = track.values.slice(frame * 3, frame * 3 + 3);",
            "                if (valueAtFrame.length === 3) {",
            "                  bone.position.set(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2]);",
            "                }",
            "              } else if (trackType === 'quaternion') {",
            "                const valueAtFrame = track.values.slice(frame * 4, frame * 4 + 4);",
            "                if (valueAtFrame.length === 4) {",
            "                  bone.quaternion.set(valueAtFrame[0], valueAtFrame[1], valueAtFrame[2], valueAtFrame[3]);",
            "                }",
            "              }",
            "            }",
            "          }",
            "        });",
            "",
            "        node.skeleton.update();",
            "",
            "        if (progress < 1) {",
            "          requestAnimationFrame(animate);",
            "        } else {",
            "          animationData[boneGroupName] = endFrame;",
            "        }",
            "      }",
            "",
            "      if (!animationData[boneGroupName]) {",
            "        requestAnimationFrame(animate);",
            "      }",
            "    }",
            "  });",
            "}",
            "",
            "if (objects.length > 0) {",
            "  const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "  objects.forEach(obj => {",
            "    const animationName = eventsFunctionContext.getArgument(\"animationName\");",
            "    const boneGroupName = eventsFunctionContext.getArgument(\"boneGroupName\");",
            "    const startFrame = eventsFunctionContext.getArgument(\"startFrame\") || 0;",
            "    const endFrame = eventsFunctionContext.getArgument(\"endFrame\") || 0;",
            "    const speed = eventsFunctionContext.getArgument(\"speed\") || 1;",
            "    playAnimationForBoneGroup(obj, animationName, boneGroupName, startFrame, endFrame, speed);",
            "  });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        },
        {
          "description": "boneGroupName",
          "name": "boneGroupName",
          "type": "string"
        },
        {
          "description": "startFrame",
          "longDescription": "Pick any frame to start animation from",
          "name": "startFrame",
          "supplementaryInformation": "[\"startFrame\",\"endFrame\"]",
          "type": "expression"
        },
        {
          "description": "endFrame",
          "longDescription": "Pick any frame to end animation at",
          "name": "endFrame",
          "type": "expression"
        },
        {
          "description": "Bones moving speed",
          "name": "speed",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Is transition in progress",
      "fullName": "Is transition in progress",
      "functionType": "ExpressionAndCondition",
      "name": "IsMovingInProgress",
      "sentence": "Is transition in progress for: _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "        ",
            "        if (!threeScene.userData[gdName].transition) {",
            "            threeScene.userData[gdName].transition = {",
            "            currentAnimationId: null,",
            "            isTransitioning: false",
            "            };",
            "        }",
            "",
            "        const transitionData = threeScene.userData[gdName].transition.isTransitioning;",
            "        eventsFunctionContext.returnValue = transitionData;",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "stringWithSelector"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Animation name",
      "fullName": "Animation name",
      "functionType": "StringExpression",
      "name": "IsAnimationName",
      "sentence": "Animation name of: _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "        ",
            "        if (!threeScene.userData[gdName].animation) {",
            "            threeScene.userData[gdName].animation = {",
            "            currentFrame: null,",
            "            animationName: null ",
            "            };",
            "        }",
            "",
            "        const animationName = threeScene.userData[gdName].animation.animationName;",
            "        eventsFunctionContext.returnValue = animationName;",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "string"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Is animation name equal to",
      "fullName": "Is animation name equal to",
      "functionType": "ExpressionAndCondition",
      "name": "IsAnimationNameEqual",
      "sentence": "Is animation name of: _PARAM1_ Equals to: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "        ",
            "        if (!threeScene.userData[gdName].animation) {",
            "            threeScene.userData[gdName].animation = {",
            "            currentFrame: null,",
            "            animationName: null ",
            "            };",
            "        }",
            "",
            "        const animationName = threeScene.userData[gdName].animation.animationName;",
            "        const animationCompared = eventsFunctionContext.getArgument(\"animationName\");",
            "",
            "        if (animationName === animationCompared) {",
            "            eventsFunctionContext.returnValue = true;",
            "        } else {",
            "            eventsFunctionContext.returnValue = false;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "stringWithSelector"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Current frame",
      "fullName": "Current frame",
      "functionType": "ExpressionAndCondition",
      "name": "IsCurrentFrame",
      "sentence": "Current frame for: _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "        ",
            "        if (!threeScene.userData[gdName].transition) {",
            "            threeScene.userData[gdName].transition = {",
            "            currentAnimationId: null,",
            "            isTransitioning: false",
            "            };",
            "        }",
            "",
            "        if (!threeScene.userData[gdName].animation) {",
            "            threeScene.userData[gdName].animation = {",
            "            currentFrame: null",
            "            };",
            "        }",
            "",
            "",
            "        const frameData = threeScene.userData[gdName].animation.currentFrame;",
            "        eventsFunctionContext.returnValue = frameData;",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Max frames amount",
      "fullName": "Max frames amount",
      "functionType": "ExpressionAndCondition",
      "name": "IsMaxFrameAmount",
      "sentence": "Max frames amount for: _PARAM1_ Animation name: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const animationName = eventsFunctionContext.getArgument(\"animationName\");",
            "    objects.forEach(obj => {",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "",
            "        const animationsList = obj.getRenderer()._originalModel.animations;",
            "        const animation = animationsList.find(anim => anim.name === animationName);",
            "        if (!animation) {",
            "            return;",
            "        }",
            "",
            "        const boneTracks = animation.tracks.filter(track => track.name.includes('.position') || track.name.includes('.quaternion'));",
            "        const totalFrames = (boneTracks[0].times.length)-1 || 0;",
            "        eventsFunctionContext.returnValue = totalFrames;",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Animation name",
          "name": "animationName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show bone names (DEBUG console)",
      "fullName": "Show bone names (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowBoneNames",
      "sentence": "Show bone names (DEBUG console) for:  _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    const bonesList = [];",
            "                    node.skeleton.bones.forEach((bone) => {",
            "                        bonesList.push(bone.name);           ",
            "                    });",
            "                    const bonesListString = bonesList.join(',');",
            "                    console.log(`Bones of ${gdName} with uuid ${node.uuid} : ${bonesListString}`);",
            "                }",
            "            });             ",
            "        }        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show bone including names (DEBUG console)",
      "fullName": "Show bone including names (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowBoneIncludeChars",
      "sentence": "Show bone including names (DEBUG console) for:  _PARAM1_ Names: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const boneNamesToSearch = eventsFunctionContext.getArgument(\"boneNamesToSearch\").split(',').map(name => name.trim().toLowerCase());",
            "",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    const bonesList = [];",
            "                    node.skeleton.bones.forEach((bone) => {",
            "                        const boneNameLower = bone.name.toLowerCase();",
            "                        if (boneNamesToSearch.some(searchName => boneNameLower.includes(searchName))) {",
            "                            bonesList.push(bone.name);",
            "                        }",
            "                    });",
            "                    const bonesListString = bonesList.join(',');",
            "                    console.log(`Bones of ${gdName} with uuid ${node.uuid} : ${bonesListString}`);",
            "                }",
            "            });             ",
            "        }        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Array of names",
          "longDescription": "Example: if a mesh has bones  \"LegBoneUp\",  \"LegBoneLow\" and you write \"leg\" here all bones with \"Leg\" or \"leg\" will be shown",
          "name": "boneNamesToSearch",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show all bone groups (DEBUG console)",
      "fullName": "Show all bone groups (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowAllBoneGroups",
      "sentence": "Show all bone groups (DEBUG console) for:  _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    if (!scene.userData || !scene.userData[gdName] || !scene.userData[gdName].boneGroups ) {",
            "                        return;",
            "                    }",
            "",
            "                    console.log(`All bone groups of ${JSON.stringify(gdName)} :  ${JSON.stringify(scene.userData[gdName].boneGroups)}`)",
            "                }",
            "            });             ",
            "        }",
            "        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show animations list (DEBUG console)",
      "fullName": "Show animations list (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowAnimationsList",
      "sentence": "Show animations list (DEBUG console) for:  _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh) {",
            "                    const animations = obj._animations;",
            "                    if (animations.length === 0) {",
            "                        return;",
            "                    }",
            "",
            "                    console.log(`Animations of ${JSON.stringify(gdName)} :  ${JSON.stringify(animations)}`)",
            "                }",
            "            });             ",
            "        }",
            "        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show a bone group's bones (DEBUG console)",
      "fullName": "Show a bone group's bones (DEBUG console)",
      "functionType": "Action",
      "group": "Debug animations",
      "name": "ShowBoneGroupBones",
      "sentence": "Show a bone group's bones (DEBUG console) for:  _PARAM1_ Group name: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const scene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const groupName = eventsFunctionContext.getArgument(\"groupName\");",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh && node.material.isMaterial) {",
            "                    if (!scene.userData || !scene.userData[gdName] || !scene.userData[gdName].boneGroups ) {",
            "                        return;",
            "                    }",
            "                    const boneGroup = scene.userData[gdName].boneGroups[groupName];",
            "                    const bonesListString = boneGroup.join(',');",
            "                    if (bonesListString.length > 0) {",
            "                        console.log(`Bone group bones of ${JSON.stringify(gdName)} for group name ${JSON.stringify(groupName)} :  ${JSON.stringify(bonesListString)}`)",
            "                    }",
            "                }",
            "            });             ",
            "        }        ",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Bone group name",
          "name": "groupName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Create bone group",
      "fullName": "Create bone group",
      "functionType": "Action",
      "name": "CreateBoneGroup",
      "sentence": "Create bone group for:  _PARAM1_ Bone names: _PARAM2_ Bone group name: _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    const threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    const boneNames = eventsFunctionContext.getArgument(\"boneNames\").replace(/\\s+/g, '').split(',');",
            "    const boneGroupName = eventsFunctionContext.getArgument(\"groupName\");",
            "",
            "    objects.forEach((obj, index) => {",
            "        const gdName = obj.getName() + obj.getUniqueId();",
            "        const rendererObject = obj.get3DRendererObject();",
            "        const bonesList = [];",
            "",
            "        if (rendererObject) {",
            "            rendererObject.traverse((node) => {",
            "                if (node.isSkinnedMesh) {",
            "                    node.skeleton.bones.forEach((bone) => {",
            "                        if (boneNames.includes(bone.name) && !bonesList.includes(bone.name)) {",
            "                            bonesList.push(bone.name);",
            "                        }",
            "                    });",
            "                }",
            "            });",
            "        }",
            "",
            "        if (!threeScene.userData[gdName]) {",
            "            threeScene.userData[gdName] = {};",
            "        }",
            "        if (!threeScene.userData[gdName].boneGroups) {",
            "            threeScene.userData[gdName].boneGroups = {};",
            "        }",
            "        if (!threeScene.userData[gdName].boneGroups[boneGroupName]) {",
            "            threeScene.userData[gdName].boneGroups[boneGroupName] = [];",
            "        }",
            "",
            "        bonesList.forEach(boneName => {",
            "            if (!threeScene.userData[gdName].boneGroups[boneGroupName].includes(boneName)) {",
            "                threeScene.userData[gdName].boneGroups[boneGroupName].push(boneName);",
            "            }",
            "        });",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Bone names list ",
          "longDescription": "\"bone1,bone2,bone3...\"",
          "name": "boneNames",
          "type": "string"
        },
        {
          "description": "Group name",
          "name": "groupName",
          "type": "string"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}